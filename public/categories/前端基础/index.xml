<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>前端基础 - 分类 - 3分钟实验室</title>
        <link>http://example.org/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/</link>
        <description>前端基础 - 分类 - 3分钟实验室</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Tue, 25 Apr 2023 00:00:00 &#43;0000</lastBuildDate><atom:link href="http://example.org/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/" rel="self" type="application/rss+xml" /><item>
    <title>JavaScript Promise async await</title>
    <link>http://example.org/promise/</link>
    <pubDate>Tue, 25 Apr 2023 00:00:00 &#43;0000</pubDate>
    <author>左风</author>
    <guid>http://example.org/promise/</guid>
    <description><![CDATA[状态 promise 的状态分为三种
初始状态(pending) 成功状态(fulfilled) 失败状态(rejected) 一个promise一定处于这三种状态，不可能是其他状态。 构造函数 创建一个promise需要通过构造函数
1 new Promise((resolve, reject) =&gt; {}); 构造函数接收一个函数作为参数，而这个函数的参数resolve，reject 都是函数。 调用resolve 可以使这个promise的状态从 初始状态(pending) 变为 成功状态(fulfilled)。 调用reject 可以使这个promise的状态从 初始状态(pending) 变为 失败状态(rejected) 。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 console.log( new Promise((resolve, reject) =&gt; { resolve() }) ); /*打印结果 [[Prototype]]: promise [[promiseState]]: &#34;fulfilled&#34; 注意看这里的状态 [[promiseResult]]: undefined */ console.log( new Promise((resolve, reject) =&gt; { reject() }) ); /*打印结果 [[Prototype]]: promise [[promiseState]]: &#34;rejected&#34; 注意看这里的状态 [[promiseResult]]: undefined */ ::: tip resolve() 和 reject() 可以接收任何形式的参数，具体作用往下看 :::]]></description>
</item>
<item>
    <title>JavaScript 深浅拷贝</title>
    <link>http://example.org/copy/</link>
    <pubDate>Tue, 25 Apr 2023 00:00:00 &#43;0000</pubDate>
    <author>左风</author>
    <guid>http://example.org/copy/</guid>
    <description><![CDATA[概念 浅拷贝和深拷贝主要针对的是引用数据类型（数组 对象），基础数据类型不存在深浅拷贝问题。
浅拷贝 1 2 3 4 5 6 7 8 9 10 const obj1 = { name: &#34;小明&#34;, age: &#34;18&#34;, }; const obj2 = obj1; obj2.name = &#34;小红&#34;; console.log(obj1.name); // 小红 console.log(obj2.name); // 小红 这里我们发现，更改了obj2.name之后 obj1.name 也变成了小红，这就是浅拷贝。 原因是因为obj1和obj2引用的是同一块内存地址,严格意义上都是相等的。
1 console.log(obj1 === obj2);// true 深拷贝 不难发现，基础数据类型不会出现浅拷贝的情况，而引用数据类型中的属性 例如obj1.name就是基础数据类型。
如果我们这样操作就不会出现浅拷贝的情况。
1 2 3 4 5 6 7 8 9 10 11 12 const obj1 = { name: &#34;小明&#34;, age: &#34;18&#34;, }; const obj2 = {}; obj2.]]></description>
</item>
<item>
    <title>JavaScript 事件循环 异步</title>
    <link>http://example.org/eventloop/</link>
    <pubDate>Tue, 25 Apr 2023 00:00:00 &#43;0000</pubDate>
    <author>左风</author>
    <guid>http://example.org/eventloop/</guid>
    <description><![CDATA[首先介绍几个概念，这里先做了解，后面用到再看。
同步任务
整个script脚本，除异步任务外，都是同步任务。。。
异步任务
包括setTimeout, setInterval, promise.then, 各种事件绑定等。
其中异步任务又分为
宏任务 setTimeout, setInterval, ajax请求，各种事件绑定等。 微任务promise.then 下面介绍我们运行js代码拥有哪些东西。
js执行栈(js主线程) 运行环境(这里主要指的是浏览器) 宏任务队列 微任务队列
如下图所示 由于js是单线程的，所以任务只能一个个执行，下面我们整理一下代码的执行流程。
1.js代码从上往下执行，同步任务直接执行。 2.如遇到异步任务则需要判断是宏任务还是微任务，把宏任务加入到宏任务队列，微任务加入到微任务队列。 3.执行栈中任务执行完毕，js线程空闲，检查微任务队列是否有微任务，如果有则把微任务加入执行栈并执行，直到微任务队列为空。 4.当执行栈，微任务队列都为空时，检查宏任务队列是否有宏任务，如果有取第一个加入执行栈并执行，回到第一步。 简单来说就是 同步任务 &ndash;&gt; 所有微任务 &ndash;&gt; 单个宏任务 &ndash;&gt; 所有微任务 &ndash;&gt; 单个宏任务 如此循环。
下面代码演示。 1 2 3 4 5 6 7 8 9 10 11 12 13 console.log(1); // 同步任务立马执行 setTimeout(() =&gt; { console.log(2); // 异步宏任务 放入宏任务队列 }, 0); new Promise((resolve, reject) =&gt; { resolve(); }).then(() =&gt; { console.]]></description>
</item>
<item>
    <title>JavaScript 原型 原型链</title>
    <link>http://example.org/prototype/</link>
    <pubDate>Tue, 25 Apr 2023 00:00:00 &#43;0000</pubDate>
    <author>左风</author>
    <guid>http://example.org/prototype/</guid>
    <description><![CDATA[构造函数 了解原型之前我们需要明白另外一件事情，什么是构造函数。
function student(){} 这是一个函数,我们可以直接调用它student()因为它的函数体是空的,所以不会执行任何操作。
但我们还有另外一种办法调用它 那就是new let a = new student()这句代码意思是 创建一个 student 类型的对象 a 把student()函数当构造函数使用。
其实所有的函数只要使用new来调用都是构造函数，反过来说构造函数和函数的区别就是是否用new来调用。
1 2 3 4 function student() {} let a = new student(); console.log(a); //student {} console.log(a instanceof student); //true 下面我们给出一个稍微标准点的构造函数。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function student(name, age) { this.name = name; this.age = age; this.sayName = function () { console.]]></description>
</item>
<item>
    <title>JavaScript Array 常用方法</title>
    <link>http://example.org/array/</link>
    <pubDate>Sun, 23 Apr 2023 00:00:00 &#43;0000</pubDate>
    <author>左风</author>
    <guid>http://example.org/array/</guid>
    <description><![CDATA[Array forEach forEach 循环的时候会不会改变原数组要看数组中的值是原始数据类型还是引用数据类型。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 const arr1 = [&#34;火龙果&#34;, &#34;草莓&#34;, &#34;车厘子&#34;, &#34;橘子&#34;]; arr1.forEach((item) =&gt; { item = &#34;苹果&#34;; }); console.log(arr1); // 原始数据类型 不会改变原数组 /* [ &#34;火龙果&#34;, &#34;草莓&#34;, &#34;车厘子&#34;, &#34;橘子&#34; ] */ const arr2 = [ { name: &#34;火龙果&#34; }, { name: &#34;草莓&#34; }, { name: &#34;车厘子&#34; }, { name: &#34;橘子&#34; }, ]; arr2.]]></description>
</item>
<item>
    <title>JavaScript 闭包</title>
    <link>http://example.org/closure/</link>
    <pubDate>Sun, 23 Apr 2023 00:00:00 &#43;0000</pubDate>
    <author>左风</author>
    <guid>http://example.org/closure/</guid>
    <description><![CDATA[概念 闭包是指一个函数对周围状态的引用捆绑在一起，简单说就是内层函数引用外层函数的变量。
1 2 3 4 5 6 7 // 下面这段代码就形成了一个闭包。 function fn (){ const a = &#39;123&#39; function ok(){ console.log(a) // 这里使用了外层函数 fn的变量a } } 示例 1 2 3 4 5 6 7 8 9 10 11 function count (){ let i = 0 return function ok(){ i++ console.log(i) } } const fn = count() fn() 上面代码实现了一个计数功能，变量i成为私有变量，外部可以使用但不能修改，因为js的垃圾回收机制，i一直不会被回收。
闭包就是作用域链自然产生的结果，了解作用域链和垃圾回收机制，闭包就理解了。]]></description>
</item>
<item>
    <title>JavaScript 变量声明</title>
    <link>http://example.org/variate/</link>
    <pubDate>Sun, 23 Apr 2023 00:00:00 &#43;0000</pubDate>
    <author>左风</author>
    <guid>http://example.org/variate/</guid>
    <description><![CDATA[var 和 let var和let最大的区别是var声明的范围是函数作用域，let声明的范围是块作用域。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 if(true){ var v = &#39;var&#39;; let l = &#39;let&#39;; } console.log(v) //var console.log(l) //l is not defined // ---------------------------------------- for (var i = 0; i &lt; 5; i++) {} for (let j = 0; j &lt; 5; j++) {} console.log(i); //5 console.log(j); //j is not defined // ---------------------------------------- function ok() { var vok = &#34;vok&#34;; let lok = &#34;lok&#34;; } ok(); console.]]></description>
</item>
<item>
    <title>JavaScript 对象</title>
    <link>http://example.org/object/</link>
    <pubDate>Sun, 23 Apr 2023 00:00:00 &#43;0000</pubDate>
    <author>左风</author>
    <guid>http://example.org/object/</guid>
    <description><![CDATA[对象的属性 对象的属性分为两种，数据属性，访问器属性。
数据属性 数据属性就是我们最长见的属性。
1 2 3 4 5 6 const obj = { name: &#34;小明&#34;, age: 18, } console.log(obj.name) // 小明 访问器属性 访问器属性不同的是它包含一个getter和setter函数，在访问这个属性和赋值时就会触发。
访问器属性是通过Object.defineProperty()定义,它接收三个参数，目标对象，属性名，和一个包含set get的对象。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 const obj = { name: &#34;小明&#34;, age: 18, id_: &#34;007&#34;, // 这里加上下划线代表是一个私有属性，不希望外部访问 }; Object.defineProperty(obj, &#34;id&#34;, { get() {// 访问obj.id的时候会触发这个函数。 console.]]></description>
</item>
<item>
    <title>JavaScript 函数</title>
    <link>http://example.org/function/</link>
    <pubDate>Sun, 23 Apr 2023 00:00:00 &#43;0000</pubDate>
    <author>左风</author>
    <guid>http://example.org/function/</guid>
    <description><![CDATA[参数 每个函数中都有一个arguments对象，它是一个数组保存调用时传入的参数，还可以通过它的length判断传入了几个参数。
1 2 3 4 5 function ok() { console.log(arguments[0], arguments[1], arguments.length); } ok(1, 2);// 打印结果 1 2 2 :::tip 这里要注意箭头函数并没有arguments :::
this 普通函数中的this指向调用者，也就是运行时确定。
1 2 3 4 5 6 7 8 9 10 function sayName() { console.log(this.name); } window.name = &#34;小红&#34;; sayName(); // 小红 全局调用指向window const obj = { name: &#34;小明&#34; }; obj.sayName = sayName; obj.sayName(); // 小明 obj调用指向obj 箭头函数中的this指向当前上下文，也就是说编译时确定。
1 2 3 4 5 6 7 8 9 10 const sayName = () =&gt; { console.]]></description>
</item>
</channel>
</rss>
