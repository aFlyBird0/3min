[{"categories":["Sealos 教程"],"content":" 先上效果图 话不多说直接开整！ ","date":"2023-06-15","objectID":"/sealos/:0:0","tags":["项目"],"title":"30 秒拥有自己的 ChatGPT（一行代码不用写）","uri":"/sealos/"},{"categories":["Sealos 教程"],"content":"预备条件 有一台能打开浏览器的电脑 有一个 ChatGPT 的 Key 如果你没有我送你一个 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 ","date":"2023-06-15","objectID":"/sealos/:1:0","tags":["项目"],"title":"30 秒拥有自己的 ChatGPT（一行代码不用写）","uri":"/sealos/"},{"categories":["Sealos 教程"],"content":"开始 浏览器打开这个网址 https://sealos.io/ 点击 在线使用 然后登陆进来。 点这个 AppLaunchpad 点右上新建 这个页面里需要输入的东西有： 文末会解释为什么填写这些，现在我们先快速搭建起来 AppName 这个随便起个名字就可以 Image Name 填写 yidadaa/chatgpt-next-web CPU 选择 1 Memory 选择 521Mi Container Ports 填写 3000 Accessible to the Public 这个点击打开 填写完这些后点击右上角 Deploy Application 到这个页面点击这个链接访问大功告成 如果访问不了就稍微等一会，可能是还没部署成功 打开之后在这里填入 ChatGPT 的 Key ok 搞定！ ","date":"2023-06-15","objectID":"/sealos/:2:0","tags":["项目"],"title":"30 秒拥有自己的 ChatGPT（一行代码不用写）","uri":"/sealos/"},{"categories":["Sealos 教程"],"content":"干了什么？ Image Name 填写 yidadaa/chatgpt-next-web ，这一步是写了一个开源项目作者提供的镜像名，这里不多做解释，如果你遇到一个项目开源并且提供的容器的部署方式（就是能找到镜像名）都可以用这种方式一建部署。 CPU 选择 1 Memory 选择 521Mi ，这里是我测试的最低能跑这个项目的配置，如果给的低了项目跑不起来。 Container Ports 填写 3000 ，这里是项目作者暴露的端口，一般都会写在部署文档上，写什么填什么就好了。 Sealos收费问题：新用户注册会送五块钱，部署这个项目大概能跑个几天，后面想继续用的话就要充钱了。 ","date":"2023-06-15","objectID":"/sealos/:3:0","tags":["项目"],"title":"30 秒拥有自己的 ChatGPT（一行代码不用写）","uri":"/sealos/"},{"categories":["Sealos 教程"],"content":"联系我 备注 ChatGPT 拉你进群。 ","date":"2023-06-15","objectID":"/sealos/:4:0","tags":["项目"],"title":"30 秒拥有自己的 ChatGPT（一行代码不用写）","uri":"/sealos/"},{"categories":["Laf"],"content":"本文主要解决三个问题 ： 云开发是什么 我们为什么需要云开发 如何快速上手地表最强云开发 Laf（https://laf.run） ","date":"2023-05-11","objectID":"/clouddevelopment/:0:0","tags":["Laf"],"title":"什么是云开发？","uri":"/clouddevelopment/"},{"categories":["Laf"],"content":"云开发是什么？ 我们来看看 GPT 怎么说。 一句话总结：云开发是一种模式，区别于传统开发，传统开发有的东西，云开发都有，传统开发能实现的，云开发也都能实现。 那么第二个问题就来了，既然都有都能实现，我们为什么需要云开发？ ","date":"2023-05-11","objectID":"/clouddevelopment/:1:0","tags":["Laf"],"title":"什么是云开发？","uri":"/clouddevelopment/"},{"categories":["Laf"],"content":"我们为什么需要云开发？ 为了搞懂这个问题，我们需要先知道传统的开发流程以及所需要的技术栈，我们这里以云开发中的战斗机 Laf（laf.run）举例。 传统开发流程： 1.购买服务器 2.配置服务器的环境数据库等 3.编写接口代码 4.把代码部署到服务器 5.前端搞定剩余工作 6.前端项目打包部署到服务器 7.后续运维工作 云开发流程： 1.打开浏览器编写接口代码 2.前端搞定剩余工作 3.项目一键托管上线到云平台 传统开发所需技术栈： 1.一门后端语言 2.后端框架 3.数据库 4.缓存技术 5.操作系统相关 6.前端三件套+框架+常用库 云开发所需技术栈： 1.云开发的数据库和文件操作 2.前端三件套+框架+常用库 了解这些之后，我想根本不需要明白这些实现细节，单单从字数上就可以感受到，云开发模式和传统开发模式之间的区别。 简单总结一下就是三省：省心省力又省钱。 用 Laf，前端我们用 js/ts 来写代码，后端接口我们还是用 js/ts 来写代码，这意味着什么？这意味着只需要掌握一门开发语言，就可以前后端通杀了，这意味着前端工程师可以瞬间变成全栈开发，意味着前端和后端再也不用吵架了。 用 Laf，可以节约服务器运维，多环境部署，告别配置调试 nginx ，告别为每个项目手动部署数据库和安全顾虑，告别 coding 一分钟发布半小时的尴尬场景等等。 什么环境配置我不懂，我只需要一台能打开浏览器的电脑就可以一把梭。 用了 Laf 之后上线接口可以是分钟级的，上线应用可以是小时级的。 就我个人来说，我一个人用 Laf 云开发一个月的时间交付了整套价值八万的教育系统（UI设计除外），一个小时搭建的 ChatGPT 网页也有上百付费用户，像其他更优秀的案例还有两名大学生用 Laf 一夜写完的 ChatMind 已经月入两万。 那么，到这里，我们应该已经找到了为什么需要使用云开发的答案。 Laf 云开发带来的开发体验犹如德芙般丝滑，其高效的开发效率和更低的开发门槛是传统开发无法比拟的。 用完 Laf 后我的内心只有一句话，天下苦开发者久矣！ ","date":"2023-05-11","objectID":"/clouddevelopment/:2:0","tags":["Laf"],"title":"什么是云开发？","uri":"/clouddevelopment/"},{"categories":["Laf"],"content":"如何快速上手地表最强云开发 Laf（https://laf.run） 1.Laf 官方提供了详细的开发文档（https://doc.laf.run） 2.关注我的 B站：3分钟实验室 接下来，我会通过视频的方式，在 B 站更新 Laf 云开发的全套教程，包括各种实战案例。包教包会，让每个开发者都能坐上 Laf 这架战斗机✈️！ ","date":"2023-05-11","objectID":"/clouddevelopment/:3:0","tags":["Laf"],"title":"什么是云开发？","uri":"/clouddevelopment/"},{"categories":["Laf"],"content":"life is short, you need laf :) ","date":"2023-05-11","objectID":"/clouddevelopment/:3:1","tags":["Laf"],"title":"什么是云开发？","uri":"/clouddevelopment/"},{"categories":["前端基础"],"content":"状态 promise 的状态分为三种 初始状态(pending) 成功状态(fulfilled) 失败状态(rejected) 一个promise一定处于这三种状态，不可能是其他状态。 ","date":"2023-04-25","objectID":"/promise/:1:0","tags":["JavaScript"],"title":"JavaScript Promise async await","uri":"/promise/"},{"categories":["前端基础"],"content":"构造函数 创建一个promise需要通过构造函数 new Promise((resolve, reject) =\u003e {}); 构造函数接收一个函数作为参数，而这个函数的参数resolve，reject 都是函数。 调用resolve 可以使这个promise的状态从 初始状态(pending) 变为 成功状态(fulfilled)。 调用reject 可以使这个promise的状态从 初始状态(pending) 变为 失败状态(rejected) 。 console.log( new Promise((resolve, reject) =\u003e { resolve() }) ); /*打印结果 [[Prototype]]: promise [[promiseState]]: \"fulfilled\" 注意看这里的状态 [[promiseResult]]: undefined */ console.log( new Promise((resolve, reject) =\u003e { reject() }) ); /*打印结果 [[Prototype]]: promise [[promiseState]]: \"rejected\" 注意看这里的状态 [[promiseResult]]: undefined */ ::: tip resolve() 和 reject() 可以接收任何形式的参数，具体作用往下看 ::: ","date":"2023-04-25","objectID":"/promise/:2:0","tags":["JavaScript"],"title":"JavaScript Promise async await","uri":"/promise/"},{"categories":["前端基础"],"content":"then 一个promise对象有一个.then方法，在promise对象的状态改变后触发。 then方法接收两个函数参数，分别对应 成功状态(fulfilled) 和 失败状态(rejected) 。 new Promise((resolve, reject) =\u003e { resolve(); }).then( (value) =\u003e {}, // 成功状态执行这个函数 value 就是 resolve 传来的参数 (reason) =\u003e {} // 失败状态执行这个函数 reason 就是 reject 传来的参数 ); 举个栗子 new Promise((resolve, reject) =\u003e { resolve(\"成功\"); }).then( (value) =\u003e { console.log(value); // 成功 }, (reason) =\u003e { console.log(reason); // 这里不会执行 因为调用的是resolve promise是成功状态 } ); new Promise((resolve, reject) =\u003e { reject(\"失败\"); }).then( (value) =\u003e { console.log(value); // 这里不会执行 因为调用的是reject promise是失败状态 }, (reason) =\u003e { console.log(reason); // 失败 } ); 下面我们写一个正儿八经的promise new Promise((resolve, reject) =\u003e { //这里假装发起一个网络请求 const res = request('123') if (res.ok) { resolve(res.data);// 成功返回数据 } else { reject(res.error);// 失败返回错误 } }).then( (value) =\u003e { console.log(value); // 成功拿到数据 }, (reason) =\u003e { console.log(reason); // 失败抛出错误 } ); .then方法的返回值还是一个promise，返回值的状态等于调用者的状态，上代码。 const res1 = new Promise((resolve, reject) =\u003e { resolve(\"成功\"); // 变成成功状态 }).then((value) =\u003e { console.log(value); }); const res2 = new Promise((resolve, reject) =\u003e { reject(\"失败\"); // 变成失败状态 }).then((value) =\u003e { console.log(value); }); const res3 = new Promise((resolve, reject) =\u003e { // 什么都不做 }).then((value) =\u003e { console.log(value); }); console.log(res1); // [[promiseState]]: \"fulfilled\" console.log(res2); // [[promiseState]]: \"rejected\" console.log(res3); // [[promiseState]]: \"pending\" 那么根据每个promise都有.then方法的定理，我们就可以实现链式调用。 const res1 = new Promise((resolve, reject) =\u003e { resolve(\"成功\"); }) .then((value) =\u003e {}) //第一步处理 .then((value) =\u003e {}) //第一步处理 .then((value) =\u003e {}) //第三步处理 ","date":"2023-04-25","objectID":"/promise/:3:0","tags":["JavaScript"],"title":"JavaScript Promise async await","uri":"/promise/"},{"categories":["前端基础"],"content":"finally finally 人如其名 不管promise的状态是变为成功还是失败它总会执行。 new Promise((resolve, reject) =\u003e { resolve(\"成功\"); }).finally(() =\u003e { console.log(\"finally\"); // finally }); new Promise((resolve, reject) =\u003e { reject(\"失败\"); }).finally(() =\u003e { console.log(\"finally\"); // finally }); ","date":"2023-04-25","objectID":"/promise/:4:0","tags":["JavaScript"],"title":"JavaScript Promise async await","uri":"/promise/"},{"categories":["前端基础"],"content":"async await async 标识符写在函数的最开头，标识这个函数为异步函数。 await 写在一个promise前面，作用有两个，暂停当前代码执行，并返回resolve返回的值，话不多说上代码。 :::tip async await必须成对使用。 ::: async function ok() { const p = new Promise((resolve, reject) =\u003e { resolve(\"成功了\"); }); const res = await p; console.log(res); // 成功了 } 这里要注意，await会暂停当前函数内的代码执行，如果promise的状态没有变为成功，则会一直等待下面的代码不会执行。 async function ok() { const p = new Promise((resolve, reject) =\u003e {}); const res = await p; console.log(\"okok\"); // 不会执行 } async function ok() { const p = new Promise((resolve, reject) =\u003e {reject()}); const res = await p; console.log(\"okok\"); // 不会执行 } 通过promise和async await组合，我们可以顺序发起网络请求。 async function ok() { // 假装 request()是接口 const res1 = await request(); const res2 = await request(res1); const res3 = await request(res2); } :::tip Promise构造函数是同步函数立即执行，then 和 finally 方法是 异步微任务。 ::: ","date":"2023-04-25","objectID":"/promise/:5:0","tags":["JavaScript"],"title":"JavaScript Promise async await","uri":"/promise/"},{"categories":["前端基础"],"content":"概念 浅拷贝和深拷贝主要针对的是引用数据类型（数组 对象），基础数据类型不存在深浅拷贝问题。 ","date":"2023-04-25","objectID":"/copy/:1:0","tags":["JavaScript"],"title":"JavaScript 深浅拷贝","uri":"/copy/"},{"categories":["前端基础"],"content":"浅拷贝 const obj1 = { name: \"小明\", age: \"18\", }; const obj2 = obj1; obj2.name = \"小红\"; console.log(obj1.name); // 小红 console.log(obj2.name); // 小红 这里我们发现，更改了obj2.name之后 obj1.name 也变成了小红，这就是浅拷贝。 原因是因为obj1和obj2引用的是同一块内存地址,严格意义上都是相等的。 console.log(obj1 === obj2);// true ","date":"2023-04-25","objectID":"/copy/:2:0","tags":["JavaScript"],"title":"JavaScript 深浅拷贝","uri":"/copy/"},{"categories":["前端基础"],"content":"深拷贝 不难发现，基础数据类型不会出现浅拷贝的情况，而引用数据类型中的属性 例如obj1.name就是基础数据类型。 如果我们这样操作就不会出现浅拷贝的情况。 const obj1 = { name: \"小明\", age: \"18\", }; const obj2 = {}; obj2.name = obj1.name; obj2.name = \"小红\"; console.log(obj1.name); // 小明 console.log(obj2.name); // 小红 console.log(obj1 === obj2); // false 但是如果一个对象的属性值很多，一个个这样赋值太麻烦了，所以我们手写一个深拷贝函数。 核心思想是遍历对象的属性，然后循环赋值。 首先确定我们的函数接收一个参数，用一个临时变量来拷贝，拷贝完毕之后返回整个临时变量。 function deepCopy(arg) { let temp; // do something return temp; } 然后我们需要判断一下需要拷贝的参数是对象还是数组，然后初始化临时变量。 function deepCopy(arg) { let temp; if (arg instanceof Object) temp = {}; if (arg instanceof Array) temp = []; return temp; } 接下来需要用到Object.keys方法获取到参数的所有属性值，因为Object.keys返回的是一个数组，所以可以直接forEach。 function deepCopy(arg) { let temp; if (arg instanceof Object) temp = {}; if (arg instanceof Array) temp = []; Object.keys(arg).forEach((item) =\u003e { temp[item] = arg[item]; }); return temp; } 看起来我们好像完成了，但是考虑以下情况。 const obj = { name: \"小明\", age: \"18\", book: [\"西游记\", \"红楼梦\", \"三国演义\", \"水浒传\"], }; const obj1 = deepCopy(obj); obj1.book[0] = \"小兵张嘎\"; console.log(obj.book[0]); //小兵张嘎 console.log(obj1.book[0]); //小兵张嘎 function deepCopy(arg) { let temp; if (arg instanceof Object) temp = {}; if (arg instanceof Array) temp = []; Object.keys(arg).forEach((item) =\u003e { temp[item] = arg[item]; }); return temp; } 这里的obj的book属性是一个数组，还是出现了浅拷贝的情况，这个时候需要用到递归来解决。 function deepCopy(arg) { let temp; if (arg instanceof Object) temp = {}; if (arg instanceof Array) temp = []; Object.keys(arg).forEach((item) =\u003e { // 这里判断一下如果是对象则递归调用 if (typeof arg[item] === Object) { temp[item] = deepCopy(arg[item]); } else { temp[item] = arg[item]; } }); return temp; } 完整代码测试一下。 const obj = { name: \"小明\", age: \"18\", book: [\"西游记\", \"红楼梦\", \"三国演义\", \"水浒传\"], }; const obj1 = deepCopy(obj); obj1.book[0] = \"小兵张嘎\"; console.log(obj.book[0]); // 西游记 console.log(obj1.book[0]); // 小兵张嘎 console.log(obj === obj1); // false console.log(obj.book === obj1.book); // false function deepCopy(arg) { let temp; if (arg instanceof Object) temp = {}; if (arg instanceof Array) temp = []; Object.keys(arg).forEach((item) =\u003e { if (typeof arg[item] === \"object\") { temp[item] = deepCopy(arg[item]); } else { temp[item] = arg[item]; } }); return temp; } ","date":"2023-04-25","objectID":"/copy/:3:0","tags":["JavaScript"],"title":"JavaScript 深浅拷贝","uri":"/copy/"},{"categories":["前端基础"],"content":"首先介绍几个概念，这里先做了解，后面用到再看。 同步任务 整个script脚本，除异步任务外，都是同步任务。。。 异步任务 包括setTimeout, setInterval, promise.then, 各种事件绑定等。 其中异步任务又分为 宏任务 setTimeout, setInterval, ajax请求，各种事件绑定等。 微任务promise.then 下面介绍我们运行js代码拥有哪些东西。 js执行栈(js主线程) 运行环境(这里主要指的是浏览器) 宏任务队列 微任务队列 如下图所示 由于js是单线程的，所以任务只能一个个执行，下面我们整理一下代码的执行流程。 1.js代码从上往下执行，同步任务直接执行。 2.如遇到异步任务则需要判断是宏任务还是微任务，把宏任务加入到宏任务队列，微任务加入到微任务队列。 3.执行栈中任务执行完毕，js线程空闲，检查微任务队列是否有微任务，如果有则把微任务加入执行栈并执行，直到微任务队列为空。 4.当执行栈，微任务队列都为空时，检查宏任务队列是否有宏任务，如果有取第一个加入执行栈并执行，回到第一步。 简单来说就是 同步任务 –\u003e 所有微任务 –\u003e 单个宏任务 –\u003e 所有微任务 –\u003e 单个宏任务 如此循环。 下面代码演示。 console.log(1); // 同步任务立马执行 setTimeout(() =\u003e { console.log(2); // 异步宏任务 放入宏任务队列 }, 0); new Promise((resolve, reject) =\u003e { resolve(); }).then(() =\u003e { console.log(3); // 异步微任务 放入微任务队列 }); console.log(4); // 同步任务立马执行 打印结果为 1 4 3 2 ::: tip 这里需要注意：只要执行栈为空，就会把微任务队列的所有任务处理完。而宏任务则是一个一个的处理。这样做的目的是可以实现插队。 ::: 下面看代码 console.log(1); // 同步任务立马执行 setTimeout(() =\u003e { console.log(2); // 异步宏任务 放入宏任务队列 new Promise((resolve, reject) =\u003e { resolve(); }).then(() =\u003e { console.log(3); // 异步微任务 放入微任务队列 }); }, 0); setTimeout(() =\u003e { console.log(4); }, 0); console.log(5); // 同步任务立马执行 打印结果是 1 5 2 3 4。 这里我们可以看到 宏任务队列有两个任务 分别是打印 2 和打印 4，但是因为打印 2 这个宏任务中又产生了打印 3 的微任务。按照事件循环机制，执行完一个宏任务后会清空微任务队列，所以先打印了3。 这样我们就利用了微任务进行插队。 最后我们解释一下运行环境的作用，当我们设置setTimeout的时候js线程并不会去计时，而是在运行环境中创建一个任务，这个任务就是计时对应的时间后把回调函数放入相应的任务队列。 那么由此可知，setTimeout定时的任务并不一定会准时执行，而是最快那个时间执行。 下图解释了浏览器的进程。 ","date":"2023-04-25","objectID":"/eventloop/:0:0","tags":["JavaScript"],"title":"JavaScript 事件循环 异步","uri":"/eventloop/"},{"categories":["前端基础"],"content":"构造函数 了解原型之前我们需要明白另外一件事情，什么是构造函数。 function student(){} 这是一个函数,我们可以直接调用它student()因为它的函数体是空的,所以不会执行任何操作。 但我们还有另外一种办法调用它 那就是new let a = new student()这句代码意思是 创建一个 student 类型的对象 a 把student()函数当构造函数使用。 其实所有的函数只要使用new来调用都是构造函数，反过来说构造函数和函数的区别就是是否用new来调用。 function student() {} let a = new student(); console.log(a); //student {} console.log(a instanceof student); //true 下面我们给出一个稍微标准点的构造函数。 function student(name, age) { this.name = name; this.age = age; this.sayName = function () { console.log(this.name); }; } const a = new student(\"小红\", \"18\"); const b = new student(\"小明\", \"20\"); console.log(a.name); // 小红 a.sayName(); // 小红 console.log(b.name); // 小明 b.sayName(); // 小明 console.log(a.sayName === b.sayName); //false 这里我们通过构造函数实例化了两个对象a和b,但是请注意最后一行，a.sayName和b.sayName并不是同一个函数，这代表需要在内存中存放两个同样的sayName函数，如果我实例化一百个对象，那么就需要存放一百个同样的函数在内存中，这显然是不好的，后面我们会通过原型来优化这个“不好”的构造函数。 ","date":"2023-04-25","objectID":"/prototype/:1:0","tags":["JavaScript"],"title":"JavaScript 原型 原型链","uri":"/prototype/"},{"categories":["前端基础"],"content":"构造函数的原型 每个函数创建时js就会为这个函数创建一个prototype属性，这个属性是一个对象，也就是我们说的原型（原型对象）。 默认情况下原型对象会自动获得一个constructor属性,指回与之关联的构造函数。 function student() {} console.log(student.prototype);// {constructor: ƒ student()} console.log(student.prototype.constructor === student); //true 现在我们知道了，每个函数都有一个原型（原型对象），其中默认包括一个constructor属性，而这个属性指向关联的构造函数，可以理解为 函数的 原型对象 里面的constructor属性 指向它自己。 ","date":"2023-04-25","objectID":"/prototype/:2:0","tags":["JavaScript"],"title":"JavaScript 原型 原型链","uri":"/prototype/"},{"categories":["前端基础"],"content":"实例的原型 除了构造函数之外，被构造函数new出来的实例也是有原型对象的，在chrome浏览器中可以通过__proto__属性来访问。（注意proto前面和后面是两个下划线） function student() {} let a = new student(); console.log(a.__proto__);// {constructor: ƒ student()} 这里我们发现实例的原型和构造函数的原型看起来一样，我们不妨测试一下。 function student() {} let a = new student(); console.log(a.__proto__ === student.prototype); // true 其实实例的原型就是从他的构造函数那里得来的，所以得出结论; 1.构造函数有一个原型。 2.原型中有一个constructor属性，指向构造函数本身。 3.实例的原型是从构造函数得到的，实例的原型===构造函数的原型。 ","date":"2023-04-25","objectID":"/prototype/:3:0","tags":["JavaScript"],"title":"JavaScript 原型 原型链","uri":"/prototype/"},{"categories":["前端基础"],"content":"原型的作用 我们已经知道原型是一个对象，有一个默认的constructor属性，那么如果给原型对象新增一些属性呢？ function student() {} student.prototype.name = \"小红\"; student.prototype.age = \"18\"; student.prototype.sayName = function () { console.log(this.name); }; console.log(student.prototype);// {name:'小红',age:'18',sayName: ƒ (), constructor: ƒ student()} student.prototype.sayName();// 小红 可以看到，成功添加并且可以使用，下面我们来创建一个实例。 function student() {} student.prototype.name = \"小红\"; student.prototype.age = \"18\"; student.prototype.sayName = function () { console.log(this.name); }; const a = new student() console.log(a.name); // 小红 a.sayName();// 小红 这里发现一个问题，我们实例化一个对象a但是我们并没有给a赋任何属性，但是我们访问a.name和a.sayName()，却能正常访问，输出的值刚好是原型中对应的值，why? 因为通过对象访问属性时，会首先搜索对象本身有没有这个属性，如果有则返回，如果没有则去搜索对象的原型有没有这个属性。 因此调用a.name会发生两步搜索。 第一步js引擎会问 对象a有name这个属性吗？ 答案是没有。 第二步js引擎会问 对象a的原型有name这个属性吗？ 答案是有，返回原型的name属性。 调用a.sayName()时会发生同样的搜索。 还记得我们那个“不好”的构造函数吗？我们现在利用原型来改造一下。 function student(name, age) { this.name = name; this.age = age; } student.prototype.sayName = function () { console.log(this.name); }; const a = new student(\"小红\", \"18\"); const b = new student(\"小明\", \"20\"); a.sayName(); // 小红 b.sayName(); // 小明 console.log(a.sayName === b.sayName); //true 问题顺利解决，不管创建多个对象，sayName这个函数也只需要在内存中存储一次了。 这里我们简单理解一下“原型”的意思，原型 就是构造函数实例化对象的模型。 如果我们想知道一个属性到底是属于原型，还是对象本身，我们可以这样做。 function student() {} student.prototype.age = \"18\"; const a = new student(); a.name = \" 小红\"; console.log(\"name\" in a); // true console.log(\"age\" in a); // true console.log(a.hasOwnProperty(\"name\")); // true console.log(a.hasOwnProperty(\"age\")); //false in操作符判断属性时会包括原型的属性，也就是说在对象本身和原型上只要能找到就会返回true，而hasOwnProperty()只有在属性属于自身时才会返回true。 ","date":"2023-04-25","objectID":"/prototype/:4:0","tags":["JavaScript"],"title":"JavaScript 原型 原型链","uri":"/prototype/"},{"categories":["前端基础"],"content":"原型链 现在回顾一下上面所说的知识； 1.构造函数有一个原型，默认有一个属性constructor指向构造函数本身。 2.实例有一个属性__proto__指向构造函数的原型。 那如果一个构造函数的原型是一个实例呢？ function grandfather() { this.name = \"小明\"; } grandfather.prototype.getName = function () { console.log(this.name); }; function father() {} father.prototype = new grandfather(); father.prototype.getName(); // 小明 现在父亲函数的原型是爷爷函数的实例，这代表通过父亲的原型对象可以访问到爷爷的getName方法。 我们用父亲函数实例化一个对象，这样就简单的实现了继承。 function grandfather() { this.name = \"小明\"; } grandfather.prototype.getName = function () { console.log(this.name); }; function father() {} father.prototype = new grandfather(); const son = new father(); son.getName(); // 小明 其实所有函数的原型都是Object的实例，所以原型链的尽头就是Object,Object的原型是null。 下面我们来感受一下原型链。 function grandfather() {} function father() {} father.prototype = new grandfather(); const son = new father(); console.log(son.__proto__ === father.prototype); // true console.log(son.__proto__.__proto__ === grandfather.prototype); // true console.log(son.__proto__.__proto__.__proto__ === Object.prototype); // true console.log(son.__proto__.__proto__.__proto__.__proto__ === null); // true ::: tip 这里补充说明一下，访问一个对象的属性时会优先搜索对象本身，然后搜索他的原型，然后是他原型的原型，按着原型链一直搜索到Object的原型为止。 ::: ","date":"2023-04-25","objectID":"/prototype/:5:0","tags":["JavaScript"],"title":"JavaScript 原型 原型链","uri":"/prototype/"},{"categories":["Laf 教程"],"content":"Laf 开发指南（比官方文档更详细）待更新 laf 金丝雀版本已经不删档上线了，作为一个使用 laf 多年的开发者，毕业设计我都是用 laf 写的… 我深知 laf 对于前端程序员意味着什么，通过简单的学习就可以进行全栈开发 部署，带来了极致的开发体验，脏活累活 laf 都帮我们解决了，用 laf 甚至可以延年益寿… 本文我根据 laf 功能模块来一一介绍，可以顺序阅读，也可以根据右边导航栏找到需要了解的模块。 如果你还不知道 laf 是什么 参考：三分钟学会 Laf :::tip 因本文图片较多，打开设备的夜间模式，或者点击本站右上角的夜间模式开关，获得最佳阅读体验。 部分图片看不清细节，PC 端 CTRL + 鼠标滚轮 放大，移动端双指放大。 ::: ","date":"2023-04-25","objectID":"/lafguide/:0:0","tags":["Laf"],"title":"Laf 开发指南","uri":"/lafguide/"},{"categories":["Laf 教程"],"content":"云函数基本功能 云函数是 laf 最重要的功能了，所以我们就从新建一个云函数开始。 进入到 laf 开发页面我们可以点击中间的立即创建和左上角的 + 符号来创建一个云函数。 参考下图的介绍来创建你的第一个云函数吧 创建完之后我们熟悉一下关于云函数都有哪些功能。 ","date":"2023-04-25","objectID":"/lafguide/:1:0","tags":["Laf"],"title":"Laf 开发指南","uri":"/lafguide/"},{"categories":["Laf 教程"],"content":"搜索 编辑 删除 ","date":"2023-04-25","objectID":"/lafguide/:1:1","tags":["Laf"],"title":"Laf 开发指南","uri":"/lafguide/"},{"categories":["Laf 教程"],"content":"编写 发布 查看 ","date":"2023-04-25","objectID":"/lafguide/:1:2","tags":["Laf"],"title":"Laf 开发指南","uri":"/lafguide/"},{"categories":["Laf 教程"],"content":"传参 调试 ","date":"2023-04-25","objectID":"/lafguide/:1:3","tags":["Laf"],"title":"Laf 开发指南","uri":"/lafguide/"},{"categories":["Laf 教程"],"content":"依赖 控制台 运行结果 ","date":"2023-04-25","objectID":"/lafguide/:1:4","tags":["Laf"],"title":"Laf 开发指南","uri":"/lafguide/"},{"categories":["Laf 教程"],"content":"集合基本功能 集合我们可以理解为数据库，每一个集合对应的就是一张表。 和创建云函数一样，我们来创建一个集合。 ","date":"2023-04-25","objectID":"/lafguide/:2:0","tags":["Laf"],"title":"Laf 开发指南","uri":"/lafguide/"},{"categories":["Laf 教程"],"content":"添加一条数据 ","date":"2023-04-25","objectID":"/lafguide/:2:1","tags":["Laf"],"title":"Laf 开发指南","uri":"/lafguide/"},{"categories":["Laf 教程"],"content":"编辑 查询 删除 ","date":"2023-04-25","objectID":"/lafguide/:2:2","tags":["Laf"],"title":"Laf 开发指南","uri":"/lafguide/"},{"categories":["Laf 教程"],"content":"存储基本功能 存储这里就是存放我们文件的地方，首先我们创建一个 bucket ","date":"2023-04-25","objectID":"/lafguide/:3:0","tags":["Laf"],"title":"Laf 开发指南","uri":"/lafguide/"},{"categories":["Laf 教程"],"content":"上传 网站托管 ","date":"2023-04-25","objectID":"/lafguide/:3:1","tags":["Laf"],"title":"Laf 开发指南","uri":"/lafguide/"},{"categories":["Laf 教程"],"content":"日志基本功能 日志就是我们云函数的执行日志，我们回到最初创建的 get-data 函数，写入以下代码，并点击右侧的运行按钮。 export async function main(ctx: FunctionContext) { console.log('我执行了') } 云函数执行之后我们回到日志界面，发现多了一条记录，这里是 log 打出来的，如果你的云函数执行报错了，这里也会出现对应的记录。 所以当你的云函数没有产生预期的效果的时候，可以来查看一下日志，说不定问题就迎刃而解了。 ","date":"2023-04-25","objectID":"/lafguide/:4:0","tags":["Laf"],"title":"Laf 开发指南","uri":"/lafguide/"},{"categories":["Laf 教程"],"content":"环境变量 点击右下角的齿轮图标到设置界面，然后点环境变量，我们可以在这里添加这个应用的一些环境变量，添加之后需要更新一下。 更新完之后我们就可以在任意云函数中取到这个环境变量了，我刚刚添加了一个 API_KEY 的环境变量，现在取一下。 import cloud from '@lafjs/cloud' export async function main(ctx: FunctionContext) { console.log(cloud.env.API_KEY) // qwer } ","date":"2023-04-25","objectID":"/lafguide/:5:0","tags":["Laf"],"title":"Laf 开发指南","uri":"/lafguide/"},{"categories":["Laf 教程"],"content":"云函数的查询功能 自己弄两张表 先把逻辑走通 ","date":"2023-04-25","objectID":"/lafguide/:6:0","tags":["Laf"],"title":"Laf 开发指南","uri":"/lafguide/"},{"categories":["Laf 教程"],"content":"云函数的 增 删 改 ","date":"2023-04-25","objectID":"/lafguide/:7:0","tags":["Laf"],"title":"Laf 开发指南","uri":"/lafguide/"},{"categories":["Laf 教程"],"content":"前端调用云函数 ","date":"2023-04-25","objectID":"/lafguide/:8:0","tags":["Laf"],"title":"Laf 开发指南","uri":"/lafguide/"},{"categories":["Laf 教程"],"content":"前端直连数据库 ","date":"2023-04-25","objectID":"/lafguide/:9:0","tags":["Laf"],"title":"Laf 开发指南","uri":"/lafguide/"},{"categories":["Laf 教程"],"content":"起步 演示系统： win11专业版（这里一定是专业版，家庭版的同学去某宝花几块钱升级一下） 首先我们需要用到一个工具 Multipass。 Multipass 是快速创建一个 linux 虚拟机的工具。 我们创建 linux 虚拟机干啥呢？用来部署 k8s 。 什么是 k8s ？ 简单理解就是可以把多台服务器，组成一个超级机器，一起来管理的一个平台。 部署k8s干啥？ 因为 laf 当前只支持在 k8s 上部署。 我们反过来说： laf 当前只支持在 k8s 上部署， k8s 只支持 linux ,而我们只有一个 windows 系统。 ","date":"2023-04-25","objectID":"/deploylaf/:1:0","tags":["Laf"],"title":"三分钟部署 laf (win 版本)","uri":"/deploylaf/"},{"categories":["Laf 教程"],"content":"安装 Multipass 点击这里安装 Multipass win 版本。 一路选择下一步安装，这个地方需要注意的是一定要选这个，如果这个选项是黑的证明你的系统不是专业版。 安装完毕之后，重启电脑。 重启完执行命令。 // 启动 laf-dev 虚拟器 分配 cpus 2 memory 4G disk 50G multipass launch --name laf-dev --cpus 2 --memory 4G --disk 50G :::tip 如果遇到 launch failed: Remote \"\" is unknown or unreachable. 请更换网络，我是用手机开热点解决的，大约会消耗800MB流量。 ::: 等待 看到以下提示代表完成，这里的意思是由于禁止挂载跳过了挂载。 我们手动开启 multipass set local.privileged-mounts=true 挂载 laf // 这里的 D:\\WorkSpace\\laf 是我电脑上的 laf 项目绝对地址，需要更换成你自己的 // 如果你还没有，先去 GitHub 上 clone multipass mount D:\\WorkSpace\\laf laf-dev:/laf/ 执行完之后需要打开 laf 项目找到 deploy/scripts/install-on-linux.sh 文件把 CRLF 改成 LF 后保存。 改完后执行命令 // 获取到我们开启的虚拟机ip multipass info laf-dev | Where-Object{$_ -match \"IPv4\"} | ForEach-Object{ ($_ -split \"\\s+\")[1] } 执行完后会出现一个 ip 地址 复制下来放在这条命令里面 multipass exec laf-dev -- sudo -u root sh /laf/deploy/scripts/install-on-linux.sh 放在这里.nip.io 网速太慢，待续。。。 如果你也和我一样下载特别慢，可以将以下代码添加到 install-on-linux.sh 文件中。 mkdir /etc/containers/ cat \u003e/etc/containers/registries.conf \u003c\u003cEOF unqualified-search-registries = [\"docker.io\"] [[registry]] prefix = \"docker.io\" location = \"dockerproxy.com\" 保存后重新运行 // 别忘了更换ip地址 multipass exec laf-dev -- sudo -u root sh /laf/deploy/scripts/install-on-linux.sh 放在这里.nip.io ","date":"2023-04-25","objectID":"/deploylaf/:2:0","tags":["Laf"],"title":"三分钟部署 laf (win 版本)","uri":"/deploylaf/"},{"categories":["Laf 教程"],"content":"直到你看到这个界面，就部署成功啦 如果本文对你有帮助，可以去 Github 给我的博客点个 star 嘛 https://github.com/zuoFeng59556/my-blog ","date":"2023-04-25","objectID":"/deploylaf/:3:0","tags":["Laf"],"title":"三分钟部署 laf (win 版本)","uri":"/deploylaf/"},{"categories":["前端框架"],"content":"起步 Next.js 能干啥？ Compiling ： 把我们写的 jsx TS 等编译成浏览器认识的 js。 Minifying ： 把代码里的 缩进 空格 换行 删掉，减少文件大小来提高性能。 Bundling ： 把多个文件打包组合成更少的文件。 Code Splitting ：把代码按需分成小块，通过只加载需要的部分来减少加载时间。 Rendering ：支持服务端渲染直接发送 html 文件到浏览器，提升渲染速度。 。。。来点更直接的，Next.js 是 react 的一个框架，提供了很多方便的功能。 以下命令创建一个 next 项目。 npx create-next-app@latest 用 vscode 打开并清空 src/pages/index.js 和 src/styles/globals.css 然后在 index.js 中贴入以下代码。 export default function Home() { return ( \u003c\u003e \u003ch1\u003e你好,next\u003c/h1\u003e \u003c/\u003e ) } npm run dev 启动项目，打开 localhost:3000 ","date":"2023-04-25","objectID":"/next/:1:0","tags":["React"],"title":"三分钟上手 Next.js","uri":"/next/"},{"categories":["前端框架"],"content":"快速刷新 更改 next 为 小明 就会发现浏览器视图已经更新，无需手动刷新，这就是快速刷新。 export default function Home() { return ( \u003c\u003e \u003ch1\u003e你好,小明\u003c/h1\u003e \u003c/\u003e ) } ","date":"2023-04-25","objectID":"/next/:2:0","tags":["React"],"title":"三分钟上手 Next.js","uri":"/next/"},{"categories":["前端框架"],"content":"路由 我们在 pages 里面新建一个文件夹 red.js 写入以下代码 export default function Red() { return ( \u003c\u003e \u003ch1\u003e我是小红\u003c/h1\u003e \u003c/\u003e ) } 浏览器访问 localhost:3000/red 哦吼，这就是路由，总结一下 无需额外配置路由，pages 下的文件名即是路由url 但是记得要默认导出 export default pages/index.js 默认路径 / 也就是首页 访问pages/login/index.js 就是 localhost:3000/login/index 下面看看如何跳转,贴入一下代码, 点击就会跳转到 localhost:3000/red import Router from \"next/router\" // 引入 router export default function Home() { function goto() { Router.push('/red') // Router.push 中传入url } return ( \u003c\u003e \u003ch1 onClick={goto}\u003e你好,小明\u003c/h1\u003e \u003c/\u003e ) } 如果想要传参数, 按照以下格式 index.js import Router from \"next/router\" // 引入 router export default function Home() { function goto() { // 跳转路由并传递参数 Router.push({ pathname: '/red', query: { name: '小明传来的' } }) } return ( \u003c\u003e \u003ch1 onClick={goto}\u003e你好,小明\u003c/h1\u003e \u003c/\u003e ) } 接收参数 red.js import { useRouter } from 'next/router' export default function Red() { // 创建 router 对象 const router = useRouter() return ( \u003c\u003e {/* 接收参数 */} \u003ch1\u003e{router.query.name}\u003c/h1\u003e \u003c/\u003e ) } 因为想先先写别的，所以这个先搁置。。。。。 ","date":"2023-04-25","objectID":"/next/:3:0","tags":["React"],"title":"三分钟上手 Next.js","uri":"/next/"},{"categories":["非技术类"],"content":"起因 故事是这样的，一个月黑风高的夜晚，我掏出手机像往常一样打开朋友圈。 一开始我是不相信的，直到我（快速的） –\u003e 打开 laf –\u003e 创建应用 –\u003e 新建云函数 –\u003e 写上三行代码 –\u003e 点击运行，呦呵！还真通了。 然后我又（快速的）–\u003e 新建前端项目 –\u003e 写点样式 –\u003e 接入laf –\u003e 写点逻辑 –\u003e 打包项目 –\u003e 上传到 laf 托管，获得一个线上的地址：https://jyf6wk-chat-gpt.site.laf.dev/ 随便问两句试试看。 不得了不得了，赶紧发给我的朋友们装个杯。 再顺手发到大型 同性交友群 技术交流群。 ","date":"2023-04-25","objectID":"/offer/:1:0","tags":["others"],"title":"三分钟写了一个专属 ChatGPT ，Laf 创始人：明天来上班！","uri":"/offer/"},{"categories":["非技术类"],"content":"契机 没多大会，一个 基友 米开朗基杨加我好友。 我一想博客也很久没更新了（主要是他叫了我一声大佬），就顺便写一篇吧，然后我（迅速又帅气的）取出我的 68键，拾光白轴，PBT豆奶键帽的键盘，行云流水的码完了一篇文章：三分钟拥有自己的 ChatGPT (从开发到上线) 这篇文章经过 米开朗基杨 的润色之后几番转载， laf 一天增加了上百个 star，四百多应用，直接送上 Github Trending。 ","date":"2023-04-25","objectID":"/offer/:2:0","tags":["others"],"title":"三分钟写了一个专属 ChatGPT ，Laf 创始人：明天来上班！","uri":"/offer/"},{"categories":["非技术类"],"content":"转折 然后，然后重点来了。 ","date":"2023-04-25","objectID":"/offer/:3:0","tags":["others"],"title":"三分钟写了一个专属 ChatGPT ，Laf 创始人：明天来上班！","uri":"/offer/"},{"categories":["非技术类"],"content":"THE END life is short, you need laf 😃 https://laf.dev/ ","date":"2023-04-25","objectID":"/offer/:4:0","tags":["others"],"title":"三分钟写了一个专属 ChatGPT ，Laf 创始人：明天来上班！","uri":"/offer/"},{"categories":["前端框架"],"content":"三分钟学会 Chakra-UI 写一个厉害的登录页 ","date":"2023-04-25","objectID":"/chakra/:0:0","tags":["React"],"title":"三分钟学会 Chakra-UI 写一个厉害的登录页","uri":"/chakra/"},{"categories":["前端框架"],"content":"起步 老规矩创建一个项目用 vscode 打开 npm create vite chakra-demo --template react cd chakra-demo code . 打开后删除 src 下的其他文件夹，只保留 App.jsx 和 main.jsx 写入以下代码 App.jsx function App() { return \u003ch1\u003e你好,chakra\u003c/h1\u003e } export default App main.jsx import React from 'react' import ReactDOM from 'react-dom/client' import App from './App' ReactDOM.createRoot(document.getElementById('root')).render( \u003cReact.StrictMode\u003e \u003cApp /\u003e \u003c/React.StrictMode\u003e, ) 准备好这些以后 安装 chakra 并且安装一下依赖 把程序 run 起来 npm i @chakra-ui/react @emotion/react @emotion/styled framer-motion npm i npm run dev 然后打开我们的 main.jsx 写入以下代码 import React from 'react' import ReactDOM from 'react-dom/client' import App from './App' import { ChakraProvider } from '@chakra-ui/react' // 引入 ReactDOM.createRoot(document.getElementById('root')).render( \u003cReact.StrictMode\u003e {/* 包住我们的App组件 */} \u003cChakraProvider\u003e \u003cApp /\u003e \u003c/ChakraProvider\u003e \u003c/React.StrictMode\u003e, ) 这个时候返回浏览器就会发现 哎？俺的 h1 怎么变的这么小只了，不用慌这说明 chakra 已经起作用了。 ","date":"2023-04-25","objectID":"/chakra/:1:0","tags":["React"],"title":"三分钟学会 Chakra-UI 写一个厉害的登录页","uri":"/chakra/"},{"categories":["前端框架"],"content":"组件和样式 打开 App.jsx 写入以下代码 import { Box, Flex } from \"@chakra-ui/react\" function App() { return ( \u003cFlex w='300px' p='10' bg='yellow.100'\u003e \u003cBox mr='10' bg='blue.100'\u003e左边\u003c/Box\u003e \u003cBox bg='blue.300'\u003e右边\u003c/Box\u003e \u003c/Flex\u003e ) } export default App 打开浏览器 发生了什么？ 我们 F12 审查元素发现， 原来 Flex 就是设置了 flex 的 div Box 就是普通的 div 那 w p bg mr 都是些啥呢？其实通过效果图不难发现 w 就是 width p 就是 padding bg 就是 background mr 就是 margin-right blue.100 就是蓝色 blue.300 就是更蓝 怎么样，是不是灰常的方便。但是这并不算啥，我们来点更厉害的。 App.jsx import { Box, Flex,useColorMode } from \"@chakra-ui/react\" function App() { const { toggleColorMode } = useColorMode() // 创建 toggleColorMode return ( \u003cFlex w='300px' p='10' bg='yellow.100'\u003e {/* 点击 左边 执行 toggleColorMode */} \u003cBox onClick={toggleColorMode} mr='10' bg='blue.100'\u003e左边\u003c/Box\u003e \u003cBox bg='blue.300'\u003e右边\u003c/Box\u003e \u003c/Flex\u003e ) } export default App 现在我们打开浏览器点击左边 就会发现 网页变成了 暗色模式，如果你再次点击 又会变成正常模式，但是我们的背景色并没有改变，我们来设置一下。 App.jsx import { Box, Flex,useColorMode,useColorModeValue } from \"@chakra-ui/react\" function App() { const { toggleColorMode } = useColorMode() // useColorMode 第一个参数是浅色模式颜色 第二个是深色模式颜色 const backColor = useColorModeValue('yellow.100','red.100') return ( // 这用上我们刚刚创建的颜色 \u003cFlex w='300px' p='10' bg={backColor} \u003e \u003cBox onClick={toggleColorMode} mr='10' bg='blue.100'\u003e左边\u003c/Box\u003e \u003cBox bg='blue.300'\u003e右边\u003c/Box\u003e \u003c/Flex\u003e ) } export default App 再次打开浏览器就会发现，深色模式和浅色模式对应的背景色发生了改变。 好吧，虽然这样很丑。。。 ","date":"2023-04-25","objectID":"/chakra/:2:0","tags":["React"],"title":"三分钟学会 Chakra-UI 写一个厉害的登录页","uri":"/chakra/"},{"categories":["前端框架"],"content":"来点厉害的 根据我们刚刚学的技能，稍微组合一下再加亿点点细节。 App.jsx // 这里引入 chakra-ui 提供的 Heading,Input,Button 组件 import { Flex,Heading,Input,Button, useColorMode,useColorModeValue } from \"@chakra-ui/react\" function App() { const { toggleColorMode } = useColorMode() const backColor = useColorModeValue('gray.100','gray.700') return ( \u003cFlex h='100vh' alignItems='center' justifyContent='center'\u003e \u003cFlex direction=\"column\" bg={backColor} p='12' rounded={6} \u003e \u003cHeading mb={6}\u003e Log in\u003c/Heading\u003e \u003cInput placeholder=\"请输入账号\" mb={3} variant=\"filled\" type='text' /\u003e \u003cInput placeholder=\"请输入密码\" variant=\"filled\" mb={6} type='password' /\u003e \u003cButton colorScheme='teal'\u003eLog in\u003c/Button\u003e \u003cButton onClick={toggleColorMode}\u003e Toggle Color Mode \u003c/Button\u003e \u003c/Flex\u003e \u003c/Flex\u003e ) } export default App 打开浏览器 点击 Toggle Color Mode 按钮 缩小一下页面 ","date":"2023-04-25","objectID":"/chakra/:3:0","tags":["React"],"title":"三分钟学会 Chakra-UI 写一个厉害的登录页","uri":"/chakra/"},{"categories":["前端框架"],"content":"ok 恭喜你已经学会了基础操作，快去官网学习更多细节吧。 如果本文对你有帮助，可以去 Github 给我的博客点个 star 嘛 https://github.com/zuoFeng59556/my-blog ","date":"2023-04-25","objectID":"/chakra/:4:0","tags":["React"],"title":"三分钟学会 Chakra-UI 写一个厉害的登录页","uri":"/chakra/"},{"categories":["前端框架"],"content":"起步 老规矩创建一个项目用 vscode 打开 npm create vite clickToComponent-demo --template react cd clickToComponent-demo // 这里顺手把依赖装了 npm i npm install click-to-react-component code . 删除 src 下面的多余文件，保留 App.jsx main.jsx 并创建 black.jsx red.jsx 分别写入以下代码 main.jsx import React from 'react' import ReactDOM from 'react-dom/client' import App from './App' // 这里引入 import { ClickToComponent } from \"click-to-react-component\"; ReactDOM.createRoot(document.getElementById('root')).render( \u003cReact.StrictMode\u003e \u003cApp /\u003e {/* 这里使用 */} \u003cClickToComponent /\u003e \u003c/React.StrictMode\u003e, ) black.jsx function Black() { return ( \u003c\u003e \u003ch1\u003e我是 Black \u003c/h1\u003e \u003c/\u003e ) } export default Black red.jsx import Black from \"./black\" function Red() { return ( \u003c\u003e \u003ch1\u003e我是 Red\u003c/h1\u003e \u003cBlack/\u003e \u003c/\u003e ) } export default Red App.jsx import Red from \"./red\" function App() { return ( \u003c\u003e \u003ch1\u003e我是 App\u003c/h1\u003e \u003cRed/\u003e \u003c/\u003e ) } export default App npm run dev 运行 这里我们的项目情况是 Red 组件包含 Black 而 App 组件包含 Red ","date":"2023-04-25","objectID":"/clicktocomponent/:1:0","tags":["React"],"title":"三分钟学会 ClickToComponent","uri":"/clicktocomponent/"},{"categories":["前端框架"],"content":"使用 ","date":"2023-04-25","objectID":"/clicktocomponent/:2:0","tags":["React"],"title":"三分钟学会 ClickToComponent","uri":"/clicktocomponent/"},{"categories":["前端框架"],"content":"首先像我这样把浏览器和 vscode 同时放在屏幕上，vscode 先不要打开文件 然后按住 alt ( mac 按 option ) 键把鼠标放在浏览器上，你会发现这里出现一个绿色的框，左键点击它 如果你和我一样是 windows 可能会遇到以下提示，同意就行了 你会惊奇的发现，你的 vscode 为你打开了你所点击的组件文件 我点击的是 Black 所以打开了 black.jsx 文件 如果你按住 alt ( mac 按 option ) 加右边右键点击，会弹出组件的包含关系，点击组件名字也可以打开对应的文件。 这也太酷了吧！！！！！！ 如果本文对你有帮助，可以去 Github 给我的博客点个 star 嘛 https://github.com/zuoFeng59556/my-blog ","date":"2023-04-25","objectID":"/clicktocomponent/:3:0","tags":["React"],"title":"三分钟学会 ClickToComponent","uri":"/clicktocomponent/"},{"categories":["Laf 教程"],"content":"laf 是什么 laf 是云开发平台，可以快速的开发应用 laf 是一个开源的 BaaS 开发平台（Backend as a Service) laf 是一个开箱即用的 serverless 开发平台 laf 是一个集「函数计算」、「数据库」、「对象存储」等于一身的一站式开发平台 laf 可以是开源版的腾讯云开发、开源版的 Google Firebase 一句话总结，可以让前端秒变全栈。点击这里去 Github 查看。 ","date":"2023-04-25","objectID":"/laf/:1:0","tags":["Laf"],"title":"三分钟学会 laf","uri":"/laf/"},{"categories":["Laf 教程"],"content":"起步 话不多说开始正题，做一个 ToDoList。 第一步 去 https://laf.dev/ 注册一个账号 第二步 像我这样创建一个应用 第三步 点击开发按钮进入开发页面 ","date":"2023-04-25","objectID":"/laf/:2:0","tags":["Laf"],"title":"三分钟学会 laf","uri":"/laf/"},{"categories":["Laf 教程"],"content":"云函数 我们新建一个函数，这个函数就是我们要写的接口。 在函数中写上以下代码return一个对象出去。 export async function main(ctx: FunctionContext) { return {name:'小明'} } 然后点击右上角发布按钮。 完成这些步骤后，我们在前端项目中调用一下试试看。 在前端项目安装 laf。 npm install laf-client-sdk vue 页面中使用 import { Cloud } from \"laf-client-sdk\"; // 引入laf // 创建cloud对象 const cloud = new Cloud({ baseUrl: \"http://pcsw70.laf.dev\", // 这里的pcsw70需要换成自己的APPID getAccessToken: () =\u003e '', // 这里暂时用不到先为空 }); // 通过 cloud.invoke 调用云函数，参数就是云函数的名字。 const res = await cloud.invoke('get-list') console.log(res) // {name:'小明'} 这里正是我们云函数get-list返回的对象 至此，我们的第一个接口就调通了，我们来总结一下。 创建一个应用。 在应用内部创建云函数，把想要给前端的数据return出去。 在前端项目引入laf，创建cloud对象，使用cloud.invoke调用云函数获取到数据。 ","date":"2023-04-25","objectID":"/laf/:3:0","tags":["Laf"],"title":"三分钟学会 laf","uri":"/laf/"},{"categories":["Laf 教程"],"content":"集合 下面我们来看看数据存放在哪里。 进入集合页面，创建一个集合。 给集合新增一条数据。 ","date":"2023-04-25","objectID":"/laf/:4:0","tags":["Laf"],"title":"三分钟学会 laf","uri":"/laf/"},{"categories":["Laf 教程"],"content":"联合起来 回到我们的get-list云函数，让我们通过云函数来查询一下集合中的内容。 编写以下代码,并且点发布哦。 import cloud from '@lafjs/cloud' // 引入cloud对象 const db = cloud.database() // 创建数据库对象 export async function main(ctx: FunctionContext) { // 从我们刚刚创建的list集合中获取数据 const res = await db.collection('list').get() return res.data } 然后在前端项目中调用。 import { Cloud } from \"laf-client-sdk\"; // 引入laf // 创建cloud对象 const cloud = new Cloud({ baseUrl: \"https://pcsw70.laf.dev\", // 这里的pcsw70需要换成自己的APPID getAccessToken: () =\u003e '', // 这里暂时用不到先为空 }); // 通过 cloud.invoke 调用云函数，参数就是云函数的名字。 const res = await cloud.invoke('get-list') console.log(res) // [{name: \"吃饭\",_id: \"63e24f81291c0d415a67766a\"}] 成功查询到集合内的数据，我们继续写增加和删除操作云函数。 创建云函数add-item并写入以下代码。 import cloud from '@lafjs/cloud' const db = cloud.database() export async function main(ctx: FunctionContext) { // 调用云函数传入的参数放在ctx.body 里面 const data = ctx.body // 为list集合添加一条数据，data要求是一个对象 const res = await db.collection('list').add(data) // res.ok 为true时操作成功，false时为失败 return res.ok } 在前端调用 import { Cloud } from \"laf-client-sdk\"; const cloud = new Cloud({ baseUrl: \"http://pcsw70.laf.dev\", getAccessToken: () =\u003e '', }); add() async function add() { // invoke的第二个参数就是云函数的参数 对应ctx.body await cloud.invoke('add-item', { name: '睡觉' }) } 调用成功后我们会发现list集合中多一条数据。 创建云函数delete-item并写入以下代码。 import cloud from '@lafjs/cloud' const db = cloud.database() export async function main(ctx: FunctionContext) { // 前端调用云函数传入的参数放在ctx.body 里面 我们拿到需要删除数据的id const { id } = ctx.body // list集合中删除一条数据，条件是 _id 的值等于前端传来的id const res = await db.collection('list').where({ _id: id }).remove() // res.ok 为true时操作成功，false时为失败 return res.ok } 在前端调用 import { Cloud } from \"laf-client-sdk\"; const cloud = new Cloud({ baseUrl: \"http://pcsw70.laf.dev\", getAccessToken: () =\u003e '', }); remove() async function remove() { await cloud.invoke('delete-item', { id: '63e25770f8f863dba23e5ddd' }) } 调用成功后我们会发现list集合中删除一条数据。 :::tip 更多操作请查看官方文档 ::: ","date":"2023-04-25","objectID":"/laf/:5:0","tags":["Laf"],"title":"三分钟学会 laf","uri":"/laf/"},{"categories":["Laf 教程"],"content":"ToDoList 成品 然后把刚刚的这些技能组合起来，稍微加亿点细节就是一个 ToDoList 啦。 \u003cscript setup\u003e import { Cloud } from \"laf-client-sdk\"; import { ref } from \"vue\"; const cloud = new Cloud({ baseUrl: \"http://pcsw70.laf.dev\", getAccessToken: () =\u003e '', }); // =====================================data===================================== const list = ref([]) const value = ref('') // =====================================function===================================== getList() async function getList() { const res = await cloud.invoke('get-list') list.value = res } async function add() { const res = await cloud.invoke('add-item', { name: value.value }) if (res) { value.value = '' getList() } } async function remove(id) { const res = await cloud.invoke('delete-item', { id }) if (res) getList() } \u003c/script\u003e \u003ctemplate\u003e \u003cdiv class=\"box\"\u003e \u003cinput v-model=\"value\" type=\"text\"\u003e \u003cbutton class=\"addButton\" @click=\"add\"\u003e添加\u003c/button\u003e \u003cul\u003e \u003cdiv class=\"itemBox\" v-for=\"item in list\" :key=\"item._id\"\u003e \u003cli class=\"itemName\"\u003e{{ item.name }}\u003c/li\u003e \u003cbutton @click=\"remove(item._id)\"\u003e移除\u003c/button\u003e \u003c/div\u003e \u003c/ul\u003e \u003c/div\u003e \u003c/template\u003e \u003cstyle scoped\u003e .box { margin: 10% 0 0 40%; width: 100%; } .addButton { margin-left: 10px; } .itemBox { display: flex; margin-top: 10px; } .itemName { width: 100px; } \u003c/style\u003e 如果本文对你有帮助，可以去 Github 给我的博客点个 star 嘛 https://github.com/zuoFeng59556/my-blog ","date":"2023-04-25","objectID":"/laf/:6:0","tags":["Laf"],"title":"三分钟学会 laf","uri":"/laf/"},{"categories":["前端框架"],"content":"起步 运行命令创建一个 react 项目。 npx create-react-app todo-list 等待创建完毕后用 vscode 打开此项目。 删除 src 下面多余文件，只保留 index.js 和 index.css 清空 index.js 和 index.css 复制以下代码到 index.js import ReactDOM from 'react-dom/client'; // 创建根节点 const root = ReactDOM.createRoot(document.getElementById('root')); // 渲染 root.render(\u003ch1\u003e你好,react\u003c/h1\u003e); 在项目目录下执行 npm run start。 访问 localhost:3000 ，就可以看到我们的内容啦。 ","date":"2023-04-25","objectID":"/react/:1:0","tags":["React"],"title":"三分钟学会 React","uri":"/react/"},{"categories":["前端框架"],"content":"JSX 刚刚这段代码在 js 中使用了 html,这就是 JSX,简单理解为 js 中可以使用 html 而 html 中也可以使用 js。 root.render(\u003ch1\u003e你好,react\u003c/h1\u003e); 示例 import ReactDOM from 'react-dom/client'; const root = ReactDOM.createRoot(document.getElementById('root')); const name = '小明' root.render(\u003ch1\u003e你好,{name}\u003c/h1\u003e); //注意是单花括号 简单记一下就是，html 中使用 js 用 {}，js 中使用 html 用 ()。 ","date":"2023-04-25","objectID":"/react/:2:0","tags":["React"],"title":"三分钟学会 React","uri":"/react/"},{"categories":["前端框架"],"content":"组件 我们可以用一个函数 return 一些 html 代码出来，这样看起来更简洁，这个函数就称为组件。 import ReactDOM from 'react-dom/client'; const root = ReactDOM.createRoot(document.getElementById('root')); root.render(\u003cList\u003e\u003c/List\u003e); // 使用组件 const name = '小明' // 组件名必须大写开头 function List() { return ( // return 出来的组件只能有一个父元素 \u003cdiv\u003e \u003ch1\u003e你好,{name}\u003c/h1\u003e \u003ch1\u003e你好,{name}\u003c/h1\u003e \u003ch1\u003e你好,{name}\u003c/h1\u003e \u003c/div\u003e ) } 当然组件中也可以嵌套组件 import ReactDOM from 'react-dom/client'; const root = ReactDOM.createRoot(document.getElementById('root')); root.render(\u003cList\u003e\u003c/List\u003e); const name = '小明' function List() { return ( \u003cdiv\u003e {/* List组件中使用Item组件 */} \u003cItem\u003e\u003c/Item\u003e \u003cItem\u003e\u003c/Item\u003e \u003cItem\u003e\u003c/Item\u003e \u003c/div\u003e ) } function Item() { return ( \u003cdiv\u003e \u003ch1\u003e你好,{name}\u003c/h1\u003e \u003c/div\u003e ) } ","date":"2023-04-25","objectID":"/react/:3:0","tags":["React"],"title":"三分钟学会 React","uri":"/react/"},{"categories":["前端框架"],"content":"props 可以给组件传入一些 props。 import ReactDOM from 'react-dom/client'; const root = ReactDOM.createRoot(document.getElementById('root')); // 传入props root.render(\u003cList name='小红' age='18' \u003e\u003c/List\u003e); function List(props) { return ( \u003cdiv\u003e {/* 组件中用 props.name 访问 */} \u003ch1\u003e你好,{props.name}\u003c/h1\u003e \u003ch1\u003e你好,{props.age}\u003c/h1\u003e \u003c/div\u003e ) } ","date":"2023-04-25","objectID":"/react/:3:1","tags":["React"],"title":"三分钟学会 React","uri":"/react/"},{"categories":["前端框架"],"content":"事件处理 事件处理使用小驼峰命名，并且不要忘记使用 js 的地方需要用 {}。 import ReactDOM from 'react-dom/client'; const root = ReactDOM.createRoot(document.getElementById('root')); root.render(\u003cList\u003e\u003c/List\u003e); function List() { function ok() { console.log('click') } return ( \u003cdiv\u003e \u003ch1 onClick={ok}\u003e你好,\u003c/h1\u003e \u003c/div\u003e ) } 如果我们需要传入参数那么需要用到 bind import ReactDOM from 'react-dom/client'; const root = ReactDOM.createRoot(document.getElementById('root')); root.render(\u003cList\u003e\u003c/List\u003e); function List() { function ok(arg) { console.log(arg) } return ( \u003cdiv\u003e \u003ch1 onClick={ok.bind(this, 'click')}\u003e你好,\u003c/h1\u003e \u003c/div\u003e ) } ","date":"2023-04-25","objectID":"/react/:3:2","tags":["React"],"title":"三分钟学会 React","uri":"/react/"},{"categories":["前端框架"],"content":"state 下面我们实现点击改变 name 的值，发现控制台输出的 name 已经变为小红，而视图没有更新。 import ReactDOM from 'react-dom/client'; const root = ReactDOM.createRoot(document.getElementById('root')); root.render(\u003cList\u003e\u003c/List\u003e); function List() { let name = '小明' function ok() { name = '小红' console.log(name); // 小红 } return ( \u003cdiv\u003e \u003ch1 onClick={ok}\u003e你好,{name}\u003c/h1\u003e \u003c/div\u003e ) } 为了解决这个问题，我们需要用到 state,引入 useState 并使用。 import ReactDOM from 'react-dom/client'; import { useState } from 'react'; // 引入 useState const root = ReactDOM.createRoot(document.getElementById('root')); root.render(\u003cList\u003e\u003c/List\u003e); function List() { // name 是属性名 setName是修改属性值时用的函数 let [name, setName] = useState('小明') function ok() { setName(\"小红\") // 修改name的值 视图更新 } return ( \u003cdiv\u003e \u003ch1 onClick={ok}\u003e你好,{name}\u003c/h1\u003e \u003c/div\u003e ) } 如果需要修改的值是引用数据类型，则情况有所不同。 react 根据引用地址是否更改变来决定是否更新视图，下面我们用数组来举例子。 import ReactDOM from 'react-dom/client'; import { useState } from 'react'; const root = ReactDOM.createRoot(document.getElementById('root')); root.render(\u003cList\u003e\u003c/List\u003e); function List() { const [arr, setArr] = useState(['小明']) function ok() { setArr(() =\u003e { // 这里我们需要复制一份新的数组 这样 temp 和 arr 就不会引用同一块内存 const temp = arr.slice() temp[0] = '小红' return temp }) } return ( \u003cdiv\u003e \u003ch1 onClick={ok}\u003e你好,{arr[0]}\u003c/h1\u003e \u003c/div\u003e ) } ","date":"2023-04-25","objectID":"/react/:3:3","tags":["React"],"title":"三分钟学会 React","uri":"/react/"},{"categories":["前端框架"],"content":"数组渲染 如果我们有一个数组要渲染到 html ,可以利用 map 来实现。 import ReactDOM from 'react-dom/client'; import { useState } from 'react'; const root = ReactDOM.createRoot(document.getElementById('root')); root.render(\u003cList\u003e\u003c/List\u003e); function List() { const [arr, setArr] = useState(['小明', '小红', '大锤']) return ( \u003cdiv\u003e {arr.map((item, index) =\u003e { {/* 这里需要给每个item绑定一个唯一的key 我们暂时用index来代替 */} return (\u003ch1 key={index}\u003e你好,{item}\u003c/h1\u003e) }) } \u003c/div\u003e ) } ","date":"2023-04-25","objectID":"/react/:4:0","tags":["React"],"title":"三分钟学会 React","uri":"/react/"},{"categories":["前端框架"],"content":"css 类名需要用 className 来定义，然后我们在 index.css 中编写 css 代码引入进来。 import ReactDOM from 'react-dom/client'; import { useState } from 'react'; import './index.css' // 引入css文件 const root = ReactDOM.createRoot(document.getElementById('root')); root.render(\u003cList\u003e\u003c/List\u003e); function List() { const [arr, setArr] = useState(['小明', '小红', '大锤']) return ( \u003cdiv\u003e {arr.map((item, index) =\u003e { // 添加类名 return (\u003ch1 className='title' key={index}\u003e你好,{item}\u003c/h1\u003e) }) } \u003c/div\u003e ) } index.css .title { color: red; } 到这里我们总结一下。 JSX 在 html 中使用 js 用 {}，js 中使用 html 用 () 代码行数过多可以提取组件 组件可以嵌套 组件可以传入 props 事件处理和类名用小驼峰命名 用state实现数据响应，引用数据类型需要另外处理 数组渲染需要用到 map ","date":"2023-04-25","objectID":"/react/:5:0","tags":["React"],"title":"三分钟学会 React","uri":"/react/"},{"categories":["前端框架"],"content":"完整代码 把上面的技能组合起来，然后再稍微加亿点细节，就是一个 ToDoList 啦！ index.js import ReactDOM from 'react-dom/client'; import \"./index.css\" import { useState } from 'react' const root = ReactDOM.createRoot(document.getElementById('root')); root.render(\u003cToDoList /\u003e); function ToDoList() { const [arr, setArr] = useState([]) const [value, setValue] = useState('') function valueChange(e) { setValue(e.target.value) } function add() { setArr(() =\u003e { const arr1 = arr.slice() arr1.push(value) return arr1 }) setValue('') } function del(index) { setArr(() =\u003e { const arr1 = arr.slice() arr1.splice(index, 1) return arr1 }) } return ( \u003cdiv className='box'\u003e \u003cinput className='input' value={value} onChange={valueChange} type=\"text\" /\u003e \u003cbutton onClick={add} \u003e添加\u003c/button\u003e {arr.map((item, index) =\u003e { return \u003cItem key={index} index={index} name={item} del={del} \u003e\u003c/Item\u003e })} \u003c/div\u003e ) } function Item(props) { return ( \u003cul\u003e \u003cdiv className='item'\u003e \u003cli className='name'\u003e{props.name}\u003c/li\u003e \u003cbutton onClick={props.del.bind(this, props.index)} \u003e删除\u003c/button\u003e \u003c/div\u003e \u003c/ul\u003e ) } index.css .box { margin: 10% 0 0 40%; } .input { margin-right: 10px; } .item { display: flex; } .name { width: 100px; } 如果本文对你有帮助，可以去 Github 给我的博客点个 star 嘛 https://github.com/zuoFeng59556/my-blog ","date":"2023-04-25","objectID":"/react/:6:0","tags":["React"],"title":"三分钟学会 React","uri":"/react/"},{"categories":["前端框架"],"content":"起步 首先创建一个项目 并安装 react-router npm create vite reactRouter-demo --template react cd .\\reactRouter-demo\\ npm install react-router-dom 用 vscode 打开并清空 src 文件夹 只保留 APP.jsx 和 main.jsx 在 App.jsx 中写入以下代码 function App() { return ( \u003ch1\u003e 你好,React Router \u003c/h1\u003e ) } export default App 然后 npm i npm run dev ","date":"2023-04-25","objectID":"/reactrouter/:1:0","tags":["React"],"title":"三分钟学会 React-Router","uri":"/reactrouter/"},{"categories":["前端框架"],"content":"配置路由 src 文件下创建 pages 文件夹 然后在 pages 文件下创建 home.jsx 和 login.jsx 并写入以下代码 home.jsx function Home() { return ( \u003ch1\u003e这里是 Home \u003c/h1\u003e ) } export default Home login.jsx function Login() { return ( \u003ch1\u003e这里是 Login\u003c/h1\u003e ) } export default Login src 下再创建一个 router 文件夹 并创建 index.jsx 文件 写入以下代码 index.jsx import Login from \"../pages/login\" import Home from \"../pages/home\" const routes = [ { path: \"/\", // 这里的斜杠代表首页 element: \u003cHome /\u003e }, { path: \"/login\", element: \u003cLogin /\u003e } ] export default routes 做完这些之后，我们修改一下 App.jsx 中的内容 import { BrowserRouter, useRoutes } from \"react-router-dom\"; import routes from \"./router\"; function RouteElement() { const element = useRoutes(routes); return element; } function App() { return ( \u003c\u003e \u003cBrowserRouter\u003e \u003cRouteElement /\u003e \u003c/BrowserRouter\u003e \u003c/\u003e ) } export default App 用浏览器访问项目的运行地址(我这里是 127.0.0.1:5173 )，就会发现 继续访问 127.0.0.1:5173/login 这样我们就完成了路由的基础配置，如果我们想添加新的页面，只需以下操作 pages 文件夹下创建 对应的文件 写完代码后默认导出 在 router/index.jsx 中引入 在 router/index.jsx 的 routes 新增一个对象 path 路径名 element 引入的组件 在项目运行地址后 加上刚刚设置的 path 即可访问 ","date":"2023-04-25","objectID":"/reactrouter/:2:0","tags":["React"],"title":"三分钟学会 React-Router","uri":"/reactrouter/"},{"categories":["前端框架"],"content":"跳转 路由跳转我们需要用到 useNavigate , 我们在 home.jsx 中写入以下代码，点击按钮即可跳转到 login 页面。 home.jsx import { useNavigate } from 'react-router-dom' // 引入 function Home() { // 创建跳转函数 const navigate = useNavigate() function goToLogin() { // 填入对应的路由 path 就是 routes 数组里面的 path navigate('/login') } return ( \u003c\u003e \u003ch1\u003e这里是 Home \u003c/h1\u003e \u003cbutton onClick={goToLogin}\u003e点我去 login \u003c/button\u003e \u003c/\u003e ) } export default Home ","date":"2023-04-25","objectID":"/reactrouter/:3:0","tags":["React"],"title":"三分钟学会 React-Router","uri":"/reactrouter/"},{"categories":["前端框架"],"content":"传参 如果一个页面需要接收参数，那么我们需要在 path 上预留一个参数占位，例如我们在 login 页面接收一个 id。 router/index.jsx import Login from \"../pages/login\" import Home from \"../pages/home\" const routes = [ { path: \"/\", element: \u003cHome /\u003e }, { // 路径后面加上 /：参数名 path: \"/login/:id\", element: \u003cLogin /\u003e }, ] export default routes 我们在跳转的时候需要把 id 带上 // 同样在 path 后面加上需要传递的参数 这里的10086就是我们传的id navigate('/login/10086') 我们在 login 页面接收一下参数 login.jsx import { useParams } from 'react-router-dom' // 引入 function Login() { const params = useParams() // 创建 params 对象 return ( // 使用参数 \u003ch1\u003e这里是 Login 我的id是{ params.id}\u003c/h1\u003e ) } export default Login ","date":"2023-04-25","objectID":"/reactrouter/:4:0","tags":["React"],"title":"三分钟学会 React-Router","uri":"/reactrouter/"},{"categories":["前端框架"],"content":"嵌套路由 在 pages 下新建一个文件 logout.jsx 写入以下代码 logout.jsx function Logout() { return ( \u003ch1\u003eThis is Logout \u003c/h1\u003e ) } export default Logout 然后我们修改一下各个文件的代码 router/index.jsx import Login from \"../pages/login\" import Logout from \"../pages/logout\" import Home from \"../pages/home\" const routes = [ { path: \"/\", element: \u003cHome /\u003e, children: [ // 二级路由 配置在一级路由的 children 里 { path: \"/login/\", element: \u003cLogin /\u003e }, { path: \"/logout/\", element: \u003cLogout /\u003e } ] } ] export default routes home.jsx import { useNavigate,Outlet } from 'react-router-dom' function Home() { const navigate = useNavigate() function goToLogin() { navigate('/login') } function goToLogout() { navigate('/logout') } return ( \u003c\u003e \u003ch1\u003e这里是 Home \u003c/h1\u003e \u003cbutton onClick={goToLogin}\u003eshow login \u003c/button\u003e \u003cbutton onClick={goToLogout}\u003eshow logout \u003c/button\u003e {/* 这里的 Outlet 是二级路由的出口 也就是渲染的地方 */} \u003cOutlet/\u003e \u003c/\u003e ) } export default Home login.jsx function Login() { return ( \u003ch1\u003e这里是 Login \u003c/h1\u003e ) } export default Login 改完以后我们访问项目运行地址 127.0.0.1:5173 注意访问的是首页哦 点击左侧 show login 按钮 点击右侧 show logout 按钮 我们发现 home 页面中使用了 login logout 两个页面，可以通过路由跳转切换，这就是嵌套路由。 使用嵌套路由需要 在一级路由中添加属性 children 并把二级路由配置进入 页面引入 Outlet 作为出口 跳转即可 ","date":"2023-04-25","objectID":"/reactrouter/:5:0","tags":["React"],"title":"三分钟学会 React-Router","uri":"/reactrouter/"},{"categories":["前端框架"],"content":"404路由 在 pages 里新建一个文件 NotFound.jsx 并写上以下代码 NotFound.jsx function NotFound() { return \u003ch1\u003e这里什么都没有哦\u003c/h1\u003e } export default NotFound 在 router/index.jsx 中引入并添加到 routes router/index.jsx import Login from \"../pages/login\" import Logout from \"../pages/logout\" import Home from \"../pages/home\" import NotFound from \"../pages/NotFound\" // 引入 const routes = [ { path: \"/\", element: \u003cHome /\u003e, children: [ { path: \"/login/\", element: \u003cLogin /\u003e }, { path: \"/logout/\", element: \u003cLogout /\u003e } ] }, { // 路径设置为 * path: \"*\", element: \u003cNotFound /\u003e, } ] export default routes 然后随便访问一个不存在的路径 例如 127.0.0.1:5173/my 发现 ","date":"2023-04-25","objectID":"/reactrouter/:6:0","tags":["React"],"title":"三分钟学会 React-Router","uri":"/reactrouter/"},{"categories":["前端框架"],"content":"ok 恭喜我们已经学会了 React Router 如果本文对你有帮助，可以去 Github 给我的博客点个 star 嘛 https://github.com/zuoFeng59556/my-blog ","date":"2023-04-25","objectID":"/reactrouter/:7:0","tags":["React"],"title":"三分钟学会 React-Router","uri":"/reactrouter/"},{"categories":["前端框架"],"content":"起步 老规矩创建一个项目用 vscode 打开 npm create vite tailwind-demo --template react cd tailwind-demo code . 打开后删除 src 下的其他文件夹，只保留 App.jsx App.css 和 main.jsx 写入以下代码 App.jsx import \"./App.css\"; function App() { return ( \u003c\u003e \u003ch1\u003e你好,tailwind\u003c/h1\u003e \u003c/\u003e ) } export default App main.jsx import React from 'react' import ReactDOM from 'react-dom/client' import App from './App' ReactDOM.createRoot(document.getElementById('root')).render( \u003cReact.StrictMode\u003e \u003cApp /\u003e \u003c/React.StrictMode\u003e, ) App.css 暂时为空 依次执行以下命令 // 安装项目依赖 npm i // 安装 tailwind npm install -D tailwindcss postcss autoprefixer // 初始化 tailwind 配置文件 npx tailwindcss init -p 执行完之后我们会发现项目里生成了两个文件 我们打开 tailwind.config.cjs 写入以下代码 /** @type {import('tailwindcss').Config} */ module.exports = { content: [ \"./index.html\", \"./src/**/*.{js,ts,jsx,tsx}\", ], theme: { extend: {}, }, plugins: [], } 然后在 App.css 中写入以下代码 @tailwind base; @tailwind components; @tailwind utilities; npm run dev 启动项目 打开浏览器会发现 耶？ h1 变得这么小只，不要慌 这说明 tailwind 起作用了 ","date":"2023-04-25","objectID":"/tailwind/:1:0","tags":["React"],"title":"三分钟学会 tailwind 和 Css 说拜拜","uri":"/tailwind/"},{"categories":["前端框架"],"content":"初体验 接下来我们改动一下 App.jsx 中的代码 import \"./App.css\"; function App() { return ( \u003c\u003e \u003cdiv className=\"text-xl mb-10 h-12 bg-blue-500\"\u003e你好,tailwind\u003c/div\u003e \u003cdiv className=\"h-10 w-10 bg-blue-200 hover:bg-blue-500\"\u003e\u003c/div\u003e \u003c/\u003e ) } export default App 打开浏览器发现 把鼠标放在下面蓝色小方块试试 发生了什么？ 我们只需要写类名就可以实现对应的样式 (对我这种时常不知道起什么类名的特别友好) h 就是 height , w 就是 width 单位 1 就是 0.25rem mb 就是 margin-bottom bg 就是 background blue-200 就是 蓝色 blue-500 就是更蓝 hover: 就是在鼠标放在上面时显示的样式 我们继续添加一些代码 App.jsx import \"./App.css\"; function App() { return ( \u003c\u003e {/* 添加的代码在此注释下面 */} \u003cdiv className=\"text-xl mb-10 h-12 bg-blue-500 md:bg-red-200 lg:bg-red-500\"\u003e你好,tailwind\u003c/div\u003e \u003cdiv className=\"h-10 w-10 bg-blue-200 hover:bg-blue-500\"\u003e\u003c/div\u003e \u003c/\u003e ) } export default App 这里我们在第一个 div 里面添加了 md:bg-red-200 lg:bg-red-500 现在我们打开浏览器，按 F12 把控制台像我这样设置在右侧 然后我们缩小页面宽度，当页面宽度缩小为 1022px 附近的时候，我们发现第一个 div 的背景色变成了淡一些的红色 我们继续缩小到 767px 附近 背景色又变成了蓝色 说到这里，应该也猜出是怎么回事了 tailwind 是移动端优先，所以没有指定前缀的类名默认是在小屏时使用 md: 前缀后的类名是屏幕在中等宽度的时候使用 lg: 前缀后的类名是在屏幕较大的时候使用 ","date":"2023-04-25","objectID":"/tailwind/:2:0","tags":["React"],"title":"三分钟学会 tailwind 和 Css 说拜拜","uri":"/tailwind/"},{"categories":["前端框架"],"content":"来点厉害的 先看一下效果图 小屏 中屏 大屏 下面代码稍微有点复杂，这里先说一下思路，做响应式的时候先写最小屏幕的样式，也就是不带前缀的，然后写中等屏幕的md：前缀的，最后写大屏lg：前缀的，是写完一个屏幕拉大之后调试着写，而不是一把梭。 这个例子是参考这个视频来做的，如果你感觉不理解，点击这里查看原视频。 最后，官方文档写的非常清晰，可以一边查阅文档一边写。 完整代码 App.jsx import \"./App.css\"; function App() { return ( \u003c\u003e \u003cdiv className=\"mx-4 my-4\"\u003e \u003cimg className=\"rounded mx-auto w-2/5 shadow-lg\" src=\"/jay.png\" alt=\"\" /\u003e \u003cdiv className=\"my-8 border rounded md:flex md:flex-wrap shadow-lg overflow-hidden\"\u003e \u003cdiv className=\"p-6 border-b md:w-1/2 md:border-r lg:w-1/4 lg:border-r-0 hover:bg-gray-800 group\"\u003e \u003ch2 className=\"text-base md:text-lg lg:text-xl font-bold mb-2 group-hover:text-white\"\u003e爱在西元前\u003c/h2\u003e \u003cp className=\"text-sm md:text-base lg:text-lg text-gray-500 group-hover:text-white\"\u003e古巴比伦王颁布了汉谟拉比法典刻在黑色的玄武岩距今已经三千七百多年你在橱窗前 凝视碑文的字眼我却在旁静静欣赏你那张我深爱的脸祭司 神殿 征战 弓箭 是谁的从前喜欢在人潮中你只属于我的那画面经过苏美女神身边 我以女神之名许愿思念像底格里斯河般的蔓延当古文明只剩下难解的语言传说就成了永垂不朽的诗篇 \u003c/p\u003e \u003c/div\u003e \u003cdiv className=\"p-6 border-b md:w-1/2 lg:w-1/4 lg:border-r lg:border-r-0 hover:bg-gray-800 group\"\u003e \u003ch2 className=\"text-base md:text-lg lg:text-xl font-bold mb-2 group-hover:text-white\"\u003e爱在西元前\u003c/h2\u003e \u003cp className=\"text-sm md:text-base lg:text-lg text-gray-500 group-hover:text-white\"\u003e古巴比伦王颁布了汉谟拉比法典刻在黑色的玄武岩距今已经三千七百多年你在橱窗前 凝视碑文的字眼我却在旁静静欣赏你那张我深爱的脸祭司 神殿 征战 弓箭 是谁的从前喜欢在人潮中你只属于我的那画面经过苏美女神身边 我以女神之名许愿思念像底格里斯河般的蔓延当古文明只剩下难解的语言传说就成了永垂不朽的诗篇 \u003c/p\u003e \u003c/div\u003e \u003cdiv className=\"p-6 border-b md:w-1/2 md:border-r lg:w-1/4 hover:bg-gray-800 group\"\u003e \u003ch2 className=\"text-base md:text-lg lg:text-xl font-bold mb-2 group-hover:text-white\"\u003e爱在西元前\u003c/h2\u003e \u003cp className=\"text-sm md:text-base lg:text-lg text-gray-500 group-hover:text-white\"\u003e古巴比伦王颁布了汉谟拉比法典刻在黑色的玄武岩距今已经三千七百多年你在橱窗前 凝视碑文的字眼我却在旁静静欣赏你那张我深爱的脸祭司 神殿 征战 弓箭 是谁的从前喜欢在人潮中你只属于我的那画面经过苏美女神身边 我以女神之名许愿思念像底格里斯河般的蔓延当古文明只剩下难解的语言传说就成了永垂不朽的诗篇 \u003c/p\u003e \u003c/div\u003e \u003cdiv className=\"p-6 md:w-1/2 lg:w-1/4 hover:bg-gray-800 group\"\u003e \u003ch2 className=\"text-base md:text-lg lg:text-xl font-bold mb-2 group-hover:text-white\"\u003e爱在西元前\u003c/h2\u003e \u003cp className=\"text-sm md:text-base lg:text-lg text-gray-500 group-hover:text-white\"\u003e古巴比伦王颁布了汉谟拉比法典刻在黑色的玄武岩距今已经三千七百多年你在橱窗前 凝视碑文的字眼我却在旁静静欣赏你那张我深爱的脸祭司 神殿 征战 弓箭 是谁的从前喜欢在人潮中你只属于我的那画面经过苏美女神身边 我以女神之名许愿思念像底格里斯河般的蔓延当古文明只剩下难解的语言传说就成了永垂不朽的诗篇 \u003c/p\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/\u003e ); } export default App; 如果本文对你有帮助，可以去 Github 给我的博客点个 star 嘛 https://github.com/zuoFeng59556/my-blog ","date":"2023-04-25","objectID":"/tailwind/:3:0","tags":["React"],"title":"三分钟学会 tailwind 和 Css 说拜拜","uri":"/tailwind/"},{"categories":["前端框架"],"content":"起步 老规矩创建一个项目用 vscode 打开 npm create vite zustand-demo --template react cd zustand-demo code . 删除 src 下多余文件 保留 App.jsx main.jsx , 并新增一个 store.js App.jsx 中写入以下代码 function App() { return \u003c\u003e\u003ch1\u003e你好,zustand\u003c/h1\u003e\u003c/\u003e; } export default App; main.jsx 中写入以下代码 import React from 'react' import ReactDOM from 'react-dom/client' import App from './App' ReactDOM.createRoot(document.getElementById('root')).render( \u003cReact.StrictMode\u003e \u003cApp /\u003e \u003c/React.StrictMode\u003e, ) 依次执行以下命令 npm i npm install zustand npm install immer npm run dev 启动项目 ","date":"2023-04-25","objectID":"/zustand/:1:0","tags":["React"],"title":"三分钟学会 zustand 优雅的管理你的状态","uri":"/zustand/"},{"categories":["前端框架"],"content":"配置 打开我们刚创建的 store.js 按照以下格式写入 import { create } from \"zustand\"; import { immer } from 'zustand/middleware/immer' const useStore = create( immer((set) =\u003e ({ count: 0, })) ); export default useStore; 现在我们创建了一个全局的 count 我们可以在任何组件中使用它 ","date":"2023-04-25","objectID":"/zustand/:2:0","tags":["React"],"title":"三分钟学会 zustand 优雅的管理你的状态","uri":"/zustand/"},{"categories":["前端框架"],"content":"使用 打开 App.js 写入以下代码 import useStore from \"./store.js\"; // 引入我们创建的 useStore function App() { // 获取到 count const count = useStore((state) =\u003e state.count); return \u003c\u003e {/* 使用 */} \u003ch1\u003e 现在的数字是{count}\u003c/h1\u003e \u003c/\u003e; } export default App; 看看效果 ","date":"2023-04-25","objectID":"/zustand/:3:0","tags":["React"],"title":"三分钟学会 zustand 优雅的管理你的状态","uri":"/zustand/"},{"categories":["前端框架"],"content":"修改 回到 store.js 我们为 count 添加上增加和减少的方法 import { create } from \"zustand\"; import { immer } from 'zustand/middleware/immer' const useStore = create( immer((set) =\u003e ({ count: 0, // 这里的括号比较多 别少复制了 addCount() { set((state) =\u003e { state.count = state.count + 1; }); }, subCount() { set((state) =\u003e { state.count = state.count - 1; }); }, })) ); export default useStore; 在 App.js 中使用 import useStore from \"./store.js\"; function App() { const count = useStore((state) =\u003e state.count); // 拿到定义的方法 const add = useStore((state) =\u003e state.addCount); const sub = useStore((state) =\u003e state.subCount); return \u003c\u003e \u003ch1\u003e 现在的数字是{count}\u003c/h1\u003e {/* 使用 */} \u003cbutton onClick={add}\u003e加\u003c/button\u003e \u003cbutton onClick={sub}\u003e减\u003c/button\u003e \u003c/\u003e; } export default App; 现在打开浏览器，随便点点两个按钮就会发现数据在变化 ","date":"2023-04-25","objectID":"/zustand/:4:0","tags":["React"],"title":"三分钟学会 zustand 优雅的管理你的状态","uri":"/zustand/"},{"categories":["前端框架"],"content":"传参修改 我们同样也可以传入参数修改 count 的值 store.js import { create } from \"zustand\"; import { immer } from 'zustand/middleware/immer' const useStore = create( immer((set) =\u003e ({ count: 0, addCount() { set((state) =\u003e { state.count = state.count + 1; }); }, subCount() { set((state) =\u003e { state.count = state.count - 1; }); }, // 这里我们接收一个参数 value setCount(value) { set((state) =\u003e { state.count = value; }); }, })) ); export default useStore; 在 App.js 中传入参数 import useStore from \"./store.js\"; function App() { const count = useStore((state) =\u003e state.count); const add = useStore((state) =\u003e state.addCount); const sub = useStore((state) =\u003e state.subCount); // 拿到方法 const set = useStore((state) =\u003e state.setCount); return \u003c\u003e \u003ch1\u003e 现在的数字是{count}\u003c/h1\u003e \u003cbutton onClick={add}\u003e加\u003c/button\u003e \u003cbutton onClick={sub}\u003e减\u003c/button\u003e {/* 使用并传入参数 888 */} \u003cbutton onClick={set.bind(this,888)}\u003e设置值为888\u003c/button\u003e \u003c/\u003e; } export default App; 回到浏览器点击 设置值为888 按钮 ","date":"2023-04-25","objectID":"/zustand/:5:0","tags":["React"],"title":"三分钟学会 zustand 优雅的管理你的状态","uri":"/zustand/"},{"categories":["前端框架"],"content":"devtools 我们在 store.js中引入 devtools 并使用 import { create } from \"zustand\"; import { immer } from 'zustand/middleware/immer' // 引入 import { devtools } from \"zustand/middleware\"; const useStore = create( // 这里用 devtools() 包住之前的内容 devtools( immer((set) =\u003e ({ count: 0, addCount() { set((state) =\u003e { state.count = state.count + 1; }); }, subCount() { set((state) =\u003e { state.count = state.count - 1; }); }, setCount(count) { set((state) =\u003e { state.count = count; }); }, })) ) ); export default useStore; 我们在浏览器中搜索 Redux DevTools 扩展并安装 浏览器中按 F12 找到这个插件 我们点击按钮发现 count 改变时 插件中会显示，插件下方还有个播放按钮和进度条，可以点击看看会发生什么好玩的事情呢。 ","date":"2023-04-25","objectID":"/zustand/:6:0","tags":["React"],"title":"三分钟学会 zustand 优雅的管理你的状态","uri":"/zustand/"},{"categories":["前端框架"],"content":"ok 至此我们已经学会了如何使用 zustand 如果本文对你有帮助，可以去 Github 给我的博客点个 star 嘛 https://github.com/zuoFeng59556/my-blog ","date":"2023-04-25","objectID":"/zustand/:7:0","tags":["React"],"title":"三分钟学会 zustand 优雅的管理你的状态","uri":"/zustand/"},{"categories":["工具"],"content":"三分钟学会参与开源，提交 pr ","date":"2023-04-25","objectID":"/pr/:0:0","tags":["GitHub"],"title":"三分钟学会参与开源，提交 PR","uri":"/pr/"},{"categories":["工具"],"content":"pr 是什么 假设： 你在 GitHub 上发现了一个开源项目。 觉得项目中有 bug,或者写的不够好。 你想出手帮帮他。 这个时候就会用到 pr (pull request)。 这里翻译为： 我改了你的代码，你快来看看把！ ","date":"2023-04-25","objectID":"/pr/:1:0","tags":["GitHub"],"title":"三分钟学会参与开源，提交 PR","uri":"/pr/"},{"categories":["工具"],"content":"项目克隆到本地 首先找到一个项目，点击右上角的 Fork 按钮，把项目复制一份到自己的 GitHub。 Fork 完之后我们到自己的仓库列表，找到刚刚复制的仓库，并 clone 到自己本地。 :::tip 这里要注意，一定是 clone 自己复制的那一份哦，而不是原仓库，没有人会让你直接更改别人代码的。 ::: 在正式改代码之前我们还需要了解一下仓库的关系。 我们现在拥有三份代码，称为三个仓库。 原作者 GitHub 上的仓库称为 upstream Fork 复制到我们自己 GitHub 上的称为 origin 从我们自己 GitHub 上 clone 到本地的称为 local 在我们项目目录下执行 git remote -v 发现只有origin仓库。 这里用 git remote add upstream 原仓库地址 来添加upstream仓库。 再次 git remote -v 查看添加成功。 至此，我们三个仓库就都关联上了。 ","date":"2023-04-25","objectID":"/pr/:2:0","tags":["GitHub"],"title":"三分钟学会参与开源，提交 PR","uri":"/pr/"},{"categories":["工具"],"content":"改代码 改别人代码之前我们还需要做一件事情，那就是基于 upstream 仓库创建一个新的分支。 为什么这里需要创建新的分支呢，为一个分支在同一时间只能提交一个 pr 所以一般建议新建一个分支来提交 pr。 // 获取到 upstream 仓库的 main 分支 git fetch upstream main // 切换到 upstream 仓库的 main 分支 git checkout upstream/main // 基于 upstream 仓库的 main 分支新建一个 feat-1 分支并切换 git switch -c feat-1 好了终于可以修改代码了 我们打开项目里仅有的 readme 文件，发现这里至少有两处错误，该大写的没大写，也不懂的使用三单。 经过我们一番修改后，看起来没有什么问题了。 ","date":"2023-04-25","objectID":"/pr/:3:0","tags":["GitHub"],"title":"三分钟学会参与开源，提交 PR","uri":"/pr/"},{"categories":["工具"],"content":"提交 然后我们提交代码。 git add . git commit -m 'fix:修复了一些语法错误' // 这里要指明提交的仓库和分支 git push origin feat-1 提交成功后，打开 GitHub 我们 Fork 的仓库发现已经有提示了，我们点击右侧绿色按钮。 如果你没有看到提示，切换到我们刚刚提交的分支，点击这里进入。 总之我们进入到这个页面，按照项目要求填写标题和描述，点击右下角 Create pull request，来创建 pr。 提交后看到这个页面，就说明我们的 pr 已经提交成功了，等作者合并你的 pr 你就成为这个项目的 contributor 啦。 ","date":"2023-04-25","objectID":"/pr/:4:0","tags":["GitHub"],"title":"三分钟学会参与开源，提交 PR","uri":"/pr/"},{"categories":["工具"],"content":"总结 Fork 到自己GitHub clone 到本地 添加 upstream 仓库 更新代码到local 创建分支 写代码 提交代码到 origin 创建 pr 成为 contributor ","date":"2023-04-25","objectID":"/pr/:5:0","tags":["GitHub"],"title":"三分钟学会参与开源，提交 PR","uri":"/pr/"},{"categories":["工具"],"content":":::tip 同一个仓库第二次提 pr 从更新代码到 local 开始就可以啦 ::: 如果本文对你有帮助，可以去 Github 给我的博客点个 star 嘛 https://github.com/zuoFeng59556/my-blog ","date":"2023-04-25","objectID":"/pr/:6:0","tags":["GitHub"],"title":"三分钟学会参与开源，提交 PR","uri":"/pr/"},{"categories":["项目开发"],"content":"OpenAI 已经公布了 ChatGPT 正式版 API，背后的新模型是 gpt-3.5-turbo，这是 OpenAI 目前最先进的模型，响应速度更快，价格更便宜。 作为开发人员，我们还是希望通过 API 将 ChatGPT 和相关模型集成到自己的产品和应用中，尴尬的是，目前无法访问 ChatGPT API，原因大家都懂得。于是网上出现了各种各样的 API 反代服务，我们可以直接通过反代服务来变相访问 ChatGPT API。 即使我们解决了 API 的访问问题，还要准备一个开发环境，比如对于 Node.js 客户端来说，需要准备一个 Node.js 环境。 有没有一种简单快捷的方法来调用 ChatGPT API 呢？ 那当然是用 Laf 了。 Laf 是一个完全开源的一站式云开发平台，提供了开箱即用的云函数，云数据库，对象存储等能力，让你可以像写博客一样写代码。 GitHub：https://github.com/labring/laf 如果你希望快速了解 Laf 的用法，可以参考这篇文章：三分钟学会 Laf。 言归正传，下面我们开始计时，三分钟时间用 Laf 实现一个自己的 ChatGPT！ 前提条件：你需要准备一个 ChatGPT 账号并且生成一个 API Key (这一步可以问 Google ) ","date":"2023-04-25","objectID":"/chatgpt/:0:0","tags":["项目"],"title":"三分钟拥有自己的 ChatGPT (从开发到上线) ","uri":"/chatgpt/"},{"categories":["项目开发"],"content":"云函数教学 首先需要登录 laf.dev，然后新建一个应用。 点击开发按钮进入开发页面。 在 NPM 依赖面板中点击右上角的 +： 然后输入 chatgpt 并回车进行搜索，选择第一个搜索结果，保存并重启： 重启之后，自定义依赖项中便出现了 chatgpt。 然后就可以像我一样新建一个云函数名字叫 send，并写入以下内容： import cloud from '@lafjs/cloud' export async function main(ctx: FunctionContext) { const { ChatGPTAPI } = await import('chatgpt') const api = new ChatGPTAPI({ apiKey: cloud.env.CHAT_GPT_API_KEY }) let res = await api.sendMessage('“鸡你太美”指的是中国大陆哪位男艺人？给你个提示，他喜欢唱、跳、篮球、Rap') console.log(res.text) return res.text } API Key 是通过环境变量 CHAT_GPT_API_KEY 传入的，所以我们还需要创建一个环境变量。点击左下角的设置图标： 依次选择「环境变量」–\u003e 「新增环境变量」，输入环境变量的名称和值，然后点击「确定」，再点击「更新」，便会重启应用。 现在点击右上角的「运行」，即可调试运行。 Perfect！现在我们来试试添加追踪上下文的功能。其实也很简单，只需要在对话时传入上一次对话的 ID 即可，代码如下： import cloud from '@lafjs/cloud' export async function main(ctx: FunctionContext) { const { ChatGPTAPI } = await import('chatgpt') const api = new ChatGPTAPI({ apiKey: cloud.env.CHAT_GPT_API_KEY }) let res = await api.sendMessage('“鸡你太美”指的是中国大陆哪位男艺人？给你个提示，他喜欢唱、跳、篮球、Rap') console.log(res.text) // 传入 parentMessageId 追踪上下文 res = await api.sendMessage('不对，他姓蔡，请重新回答', { parentMessageId: res.id }) console.log(res.text) return res.text } 运行一下看看： 好厉害，竟然两次就答对了我的问题！ 好了，现在才开始真的计时，因为刚刚是教学环节，不计入耗时😁 ","date":"2023-04-25","objectID":"/chatgpt/:1:0","tags":["项目"],"title":"三分钟拥有自己的 ChatGPT (从开发到上线) ","uri":"/chatgpt/"},{"categories":["项目开发"],"content":"云函数 接下来我们就可以开始动手打造自己的 ChatGPT 了，首先把上一节的函数替换为下面的内容： import cloud from '@lafjs/cloud' export async function main(ctx: FunctionContext) { const { ChatGPTAPI } = await import('chatgpt') const data = ctx.body // 这里需要把 api 对象放入 cloud.shared 不然无法追踪上下文 let api = cloud.shared.get('api') if (!api) { api = new ChatGPTAPI({ apiKey: cloud.env.CHAT_GPT_API_KEY }) cloud.shared.set('api', api) } let res // 这里前端如果传过来 parentMessageId 则代表需要追踪上下文 if (!data.parentMessageId) { res = await api.sendMessage(data.message) } else { res = await api.sendMessage(data.message, { parentMessageId: data.parentMessageId }) } return res } 现在应该很好理解这个函数了吧？ ","date":"2023-04-25","objectID":"/chatgpt/:2:0","tags":["项目"],"title":"三分钟拥有自己的 ChatGPT (从开发到上线) ","uri":"/chatgpt/"},{"categories":["项目开发"],"content":"前端 我们要实现的是 Web 版 ChatGPT，所以还需要一个前端页面。首先需要安装 Laf 的 SDK： $ npm install laf-client-sdk 接下来，需要创建一个 cloud 对象： import { Cloud } from \"laf-client-sdk\"; // 创建 cloud 对象 这里需要将 \u003cappid\u003e 替换成自己的 App ID const cloud = new Cloud({ baseUrl: \"https://\u003cappid\u003e.laf.dev\", getAccessToken: () =\u003e \"\", // 这里不需要授权，先填空 }); 这里我们看一下前端的核心代码，非常的简单，就是把提问的内容和上下文 id 传入云函数就可以了。 async function send() { // 我们提问的内容 const message = question.value; let res; // 与云函数逻辑一样，有上下文 id 就传入 if (!parentMessageId.value) { res = await cloud.invoke(\"send\", { message }); } else { res = await cloud.invoke(\"send\", { message, parentMessageId: parentMessageId.value }); } // 回复我们的内容在 res.text // 这个是上下文 id parentMessageId.value = res.id; } 到这一步 我们已经可以发信息给 ChatGPT 并且拿到回复的消息了。 我们只要稍微加亿点点细节，就可以变成这样： 加完这点细节之后，基本开发工作就完成了，接下来就是把项目上线分享给你的朋友，顺便装个杯。 说到上线我们现在应该要去买一台服务器安装 Nginx，配置 Nginx，解析域名，绑定域名… NO NO NO 我不允许你浪费年轻而美好的生命，life is short, you need laf 😃 ","date":"2023-04-25","objectID":"/chatgpt/:3:0","tags":["项目"],"title":"三分钟拥有自己的 ChatGPT (从开发到上线) ","uri":"/chatgpt/"},{"categories":["项目开发"],"content":"不懂前端的同学看这里 如果你不懂前端，还想搭建这个项目。 第一步：https://github.com/zuoFeng59556/chatGPT 打开这个网址。 第二步：在右上角的 star 小星星点亮 这一步特别重要） 第三步：切换分支为 feat-1 第四步：把这个项目弄到你本地，用啥方式都行。 第五步：用 vscode 或者任意编辑器打开这个项目。 第六步：找到 src/views/index.vue 把第 8 行的 \u003c APPID \u003e 换成你自己的 laf 上的 APPID。 然后 在命令行执行 npm i 之后再执行 npm run dev 就可以了。 ","date":"2023-04-25","objectID":"/chatgpt/:4:0","tags":["项目"],"title":"三分钟拥有自己的 ChatGPT (从开发到上线) ","uri":"/chatgpt/"},{"categories":["项目开发"],"content":"上线 打开你的 Laf，点击存储界面 –\u003e 点击上方加号 –\u003e 创建一个权限为 readonly 的存储桶（名字随意）。 创建完之后，在你的前端项目中运行打包命令。我这里用的是 npm run build。 打包完毕之后找到打包好的 dist 文件夹，像我一样把 dist 文件里面的所有东西都上传到我们刚刚创建的存储桶里面，记住是原封不动的上传哦，文件就是文件，文件夹就是文件夹。 上传完毕之后，发现右上角有一个 “开启网站托管”，点一下它！ 点完之后出来一个链接，我们点击一下访问看看是啥东西。 哦！我的老天鹅呀 这不就是我刚刚开发的项目吗？？ 恭喜，到这里你的项目已经上线了，快分享给你的好朋友吧！ 项目源码：https://github.com/zuoFeng59556/chatGPT 示例网站：https://lafai.io 如果本文对你有帮助，可以去 Github 给我的博客点个 star 嘛 https://github.com/zuoFeng59556/my-blog ","date":"2023-04-25","objectID":"/chatgpt/:5:0","tags":["项目"],"title":"三分钟拥有自己的 ChatGPT (从开发到上线) ","uri":"/chatgpt/"},{"categories":["前端基础"],"content":"Array ","date":"2023-04-23","objectID":"/array/:1:0","tags":["JavaScript"],"title":"JavaScript Array 常用方法","uri":"/array/"},{"categories":["前端基础"],"content":"forEach forEach 循环的时候会不会改变原数组要看数组中的值是原始数据类型还是引用数据类型。 const arr1 = [\"火龙果\", \"草莓\", \"车厘子\", \"橘子\"]; arr1.forEach((item) =\u003e { item = \"苹果\"; }); console.log(arr1); // 原始数据类型 不会改变原数组 /* [ \"火龙果\", \"草莓\", \"车厘子\", \"橘子\" ] */ const arr2 = [ { name: \"火龙果\" }, { name: \"草莓\" }, { name: \"车厘子\" }, { name: \"橘子\" }, ]; arr2.forEach((item) =\u003e { item.name = \"苹果\"; }); console.log(arr2);// 引用数据类型 会改变原数组 /* [ { \"name\": \"苹果\" }, { \"name\": \"苹果\" }, { \"name\": \"苹果\" }, { \"name\": \"苹果\" } ] */ ","date":"2023-04-23","objectID":"/array/:1:1","tags":["JavaScript"],"title":"JavaScript Array 常用方法","uri":"/array/"},{"categories":["前端基础"],"content":"map map 和forEach不同的是会返回一个新的数组，新数组中的值就是return出去的值。 const arr1 = [1, 2, 3, 4, 5]; const arr2 = arr1.map((item) =\u003e { return item + 1; }); console.log(arr2); //[2,3,4,5,6] ","date":"2023-04-23","objectID":"/array/:1:2","tags":["JavaScript"],"title":"JavaScript Array 常用方法","uri":"/array/"},{"categories":["前端基础"],"content":"filter filter 和 map一样会返回一个数组，不同的是 只有return后面的表达式为true时才会传入新的数组。 const arr1 = [1, 2, 3, 4, 5]; const arr2 = arr1.filter((item) =\u003e { return item \u003e 2; // 返回大于2的item }); console.log(arr2); // [3,4,5] ","date":"2023-04-23","objectID":"/array/:1:3","tags":["JavaScript"],"title":"JavaScript Array 常用方法","uri":"/array/"},{"categories":["前端基础"],"content":"splice splice 可以实现数组的 删除 插入 替换功能。 接收的前两个参数，指定元素的下标，要删除元素的数量，其余参数都是要添加进数组的项。 删除功能 const arr = [\"a\", \"b\", \"c\", \"d\", \"e\"]; // 这里的意思是从下标 0 的地方 删除一个元素 arr.splice(0, 1); console.log(arr); //['b', 'c', 'd', 'e'] 插入功能 const arr = [\"a\", \"b\", \"c\", \"d\", \"e\"]; // 这里的意思是在下标 0 的地方 删除 0个元素 添加 \"q\" arr.splice(0, 0, \"q\"); console.log(arr); // ['q', 'a', 'b', 'c', 'd', 'e'] // 当然我们也可以添加多个 arr.splice(0, 0, \"w\", \"e\", \"r\"); console.log(arr); // ['w', 'e', 'r', 'q', 'a', 'b', 'c', 'd', 'e'] 替换功能 const arr = [\"a\", \"b\", \"c\", \"d\", \"e\"]; // 这里的意思是在下标 0 的地方 删除 1个元素 添加 \"q\" arr.splice(0, 1, \"q\"); console.log(arr); // ['q', 'b', 'c', 'd', 'e'] ","date":"2023-04-23","objectID":"/array/:1:4","tags":["JavaScript"],"title":"JavaScript Array 常用方法","uri":"/array/"},{"categories":["前端基础"],"content":"概念 闭包是指一个函数对周围状态的引用捆绑在一起，简单说就是内层函数引用外层函数的变量。 // 下面这段代码就形成了一个闭包。 function fn (){ const a = '123' function ok(){ console.log(a) // 这里使用了外层函数 fn的变量a } } ","date":"2023-04-23","objectID":"/closure/:1:0","tags":["JavaScript"],"title":"JavaScript 闭包","uri":"/closure/"},{"categories":["前端基础"],"content":"示例 function count (){ let i = 0 return function ok(){ i++ console.log(i) } } const fn = count() fn() 上面代码实现了一个计数功能，变量i成为私有变量，外部可以使用但不能修改，因为js的垃圾回收机制，i一直不会被回收。 闭包就是作用域链自然产生的结果，了解作用域链和垃圾回收机制，闭包就理解了。 ","date":"2023-04-23","objectID":"/closure/:2:0","tags":["JavaScript"],"title":"JavaScript 闭包","uri":"/closure/"},{"categories":["前端基础"],"content":"var 和 let var和let最大的区别是var声明的范围是函数作用域，let声明的范围是块作用域。 if(true){ var v = 'var'; let l = 'let'; } console.log(v) //var console.log(l) //l is not defined // ---------------------------------------- for (var i = 0; i \u003c 5; i++) {} for (let j = 0; j \u003c 5; j++) {} console.log(i); //5 console.log(j); //j is not defined // ---------------------------------------- function ok() { var vok = \"vok\"; let lok = \"lok\"; } ok(); console.log(vok); //vok is not defined console.log(lok); //lok is not defined 还有一点有趣的是var声明的变量可以通过window对象访问,而let不行。 var v = \"var\"; let l = \"let\"; console.log(window.v); //var console.log(window.l); //undefined ","date":"2023-04-23","objectID":"/variate/:1:0","tags":["JavaScript"],"title":"JavaScript 变量声明","uri":"/variate/"},{"categories":["前端基础"],"content":"let 和 const let和const作用域相同，唯一不同的是const声明时必须赋初值，并且不允许修改。 const name = '小明'; name = '小红'; //TypeError: Assignment to constant variable. 如果const修饰的是一个对象，修改这个对象的属性是允许的。 const obj = { name: \"小明\" }; obj.name = \"小红\"; console.log(obj.name); //小红 const list = [0, 1, 2]; // 众所周知 数组也是对象 list[0] = 1; console.log(list); //[1,1,2] ","date":"2023-04-23","objectID":"/variate/:2:0","tags":["JavaScript"],"title":"JavaScript 变量声明","uri":"/variate/"},{"categories":["前端基础"],"content":"总结 能用const就用const，确定需要修改的变量用let，var抛弃不用。 ","date":"2023-04-23","objectID":"/variate/:3:0","tags":["JavaScript"],"title":"JavaScript 变量声明","uri":"/variate/"},{"categories":["前端基础"],"content":"对象的属性 对象的属性分为两种，数据属性，访问器属性。 ","date":"2023-04-23","objectID":"/object/:1:0","tags":["JavaScript"],"title":"JavaScript 对象","uri":"/object/"},{"categories":["前端基础"],"content":"数据属性 数据属性就是我们最长见的属性。 const obj = { name: \"小明\", age: 18, } console.log(obj.name) // 小明 ","date":"2023-04-23","objectID":"/object/:1:1","tags":["JavaScript"],"title":"JavaScript 对象","uri":"/object/"},{"categories":["前端基础"],"content":"访问器属性 访问器属性不同的是它包含一个getter和setter函数，在访问这个属性和赋值时就会触发。 访问器属性是通过Object.defineProperty()定义,它接收三个参数，目标对象，属性名，和一个包含set get的对象。 const obj = { name: \"小明\", age: 18, id_: \"007\", // 这里加上下划线代表是一个私有属性，不希望外部访问 }; Object.defineProperty(obj, \"id\", { get() {// 访问obj.id的时候会触发这个函数。 console.log(\"get触发\"); return this.id_; }, set(newValue) { // 这里的newValue就是设置的值，在这个例子里就是'008' console.log(\"set触发\"); this.id_ = newValue; }, }); console.log(obj.id); obj.id = \"008\"; /* 打印结果为： get触发 007 set触发 */ :::tip 我们可以通过get和set在访问属性和赋值的时候做一些操作，vue2的响应式就是使用defineProperty实现的。 ::: ","date":"2023-04-23","objectID":"/object/:1:2","tags":["JavaScript"],"title":"JavaScript 对象","uri":"/object/"},{"categories":["前端基础"],"content":"使用变量做属性名 let nameKey = \"name\"; const obj = {}; obj[nameKey] = \"小明\"; console.log(obj); // {\"name\": \"小明\"} ","date":"2023-04-23","objectID":"/object/:1:3","tags":["JavaScript"],"title":"JavaScript 对象","uri":"/object/"},{"categories":["前端基础"],"content":"常用方法 Object.keys 返回一个数组，里面是对象的属性名。 Object.values 返回一个数组，里面是对象的属性值。 Object.assign 返回一个对象，是两个对象的合并结果。(但这里是浅拷贝，具体查看浅拷贝深拷贝章节) const obj = { name: \"小明\", age: 18, }; console.log(Object.keys(obj)); // ['name', 'age'] console.log(Object.values(obj)); // ['小明', 18] const obj1 = { id: \"007\" }; const obj2 = Object.assign(obj, obj1); console.log(obj2); // {name: '小明', age: 18, id: '007'} ","date":"2023-04-23","objectID":"/object/:2:0","tags":["JavaScript"],"title":"JavaScript 对象","uri":"/object/"},{"categories":["前端基础"],"content":"参数 每个函数中都有一个arguments对象，它是一个数组保存调用时传入的参数，还可以通过它的length判断传入了几个参数。 function ok() { console.log(arguments[0], arguments[1], arguments.length); } ok(1, 2);// 打印结果 1 2 2 :::tip 这里要注意箭头函数并没有arguments ::: ","date":"2023-04-23","objectID":"/function/:1:0","tags":["JavaScript"],"title":"JavaScript 函数","uri":"/function/"},{"categories":["前端基础"],"content":"this 普通函数中的this指向调用者，也就是运行时确定。 function sayName() { console.log(this.name); } window.name = \"小红\"; sayName(); // 小红 全局调用指向window const obj = { name: \"小明\" }; obj.sayName = sayName; obj.sayName(); // 小明 obj调用指向obj 箭头函数中的this指向当前上下文，也就是说编译时确定。 const sayName = () =\u003e { console.log(this.name); }; window.name = \"小红\"; sayName(); // 小红 const obj = { name: \"小明\" }; obj.sayName = sayName; obj.sayName(); // 这里还是小红 因为sayName函数定义时的上下文是window :::tip 我们经常在回调函数中使用箭头函数的原因就是可以确定this的指向。 ::: ","date":"2023-04-23","objectID":"/function/:2:0","tags":["JavaScript"],"title":"JavaScript 函数","uri":"/function/"},{"categories":["前端基础"],"content":"call apply 函数有两个方法，call和apply，具体作用是指定this的值来调用函数。 call接收两个参数，第一个值是this，第二个值是函数的参数，上代码。 const obj = { name: \"小明\" }; function sayName(age, gender) { console.log(this.name, age, gender); } sayName.call(obj, 18, \"男\"); // 小明 18 男 apply和call作用一样，只是参数传递的形式变了，第一个参数还是接收this，第二个参数可以是数组，也可以是函数的arguments。 const obj = { name: \"小明\" }; function sayName(age, gender) { console.log(this.name, age, gender); } sayName.apply(obj, [18,'男']); // 小明 18 男 ","date":"2023-04-23","objectID":"/function/:3:0","tags":["JavaScript"],"title":"JavaScript 函数","uri":"/function/"},{"categories":["前端基础"],"content":"闭包 闭包是指一个函数对周围状态的引用捆绑在一起，简单说就是内层函数引用外层函数的变量。 // 下面这段代码就形成了一个闭包。 function fn (){ const a = '123' function ok(){ console.log(a) // 这里使用了外层函数 fn的变量a } } 下面代码实现了一个计数功能，变量i成为私有变量，外部可以使用但不能修改，因为js的垃圾回收机制，i一直不会被回收。 function count (){ let i = 0 return function ok(){ i++ console.log(i) } } const fn = count() fn() 闭包就是作用域链自然产生的结果，了解作用域链和垃圾回收机制，闭包就理解了。 ","date":"2023-04-23","objectID":"/function/:4:0","tags":["JavaScript"],"title":"JavaScript 函数","uri":"/function/"},{"categories":null,"content":"为什么是三分钟 最初学写代码的时候学习 c c++ java 以及 操作系统 计算机网络 系统结构 等专业课，常常听说要打牢基础，搞懂原理，学了很长一段时间，八股倒是背的滚瓜烂熟 可一个实际的项目也做不出来，学习的过程非常痛苦。 直到接触前端，学了一点 html 和 js 就去 vue 项目中瞎改乱写，当时对框架的概念也很模糊 大概知道一些动态绑定 v-if 之类的概念，就一边搜索一边抄，很多代码都是复制过来直接用，就这样写的很起劲 效率也非常高，等能抄的非常熟练的时候再去阅读 vue 的文档，了解其实现原理就非常有趣一点也不枯燥。 后来就总结学一个东西先快速学会简单使用，用到哪里学哪里，等用的熟了再去关心 细节 原理这些，而且这本身也就是正确的学习方式。 ","date":"0001-01-01","objectID":"/preface/:0:0","tags":null,"title":"","uri":"/preface/"},{"categories":null,"content":"这里引用一下 编程入门之道 的建议。 “这是我的第一个也是最重要的建议。 无论是学一门语言，还是学一个工具：尽可能地先用最短的时间搞懂这个东西是做什么的，然后以最快的方式把它 “run”起来。 当你已经能跑起一个语言、一个工具的最简单的示例的时候，再去花时间慢慢了解背后的复杂的内容，再去拓展即可。先用起来，跑起来，带着问题去翻资料。” 所以三分钟的目的就是，快速知道这个东西是做什么的，然后以最快的方式把它 “run” 起来。 ","date":"0001-01-01","objectID":"/preface/:0:1","tags":null,"title":"","uri":"/preface/"}]