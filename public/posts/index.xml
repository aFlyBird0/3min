<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>所有文章 - 3分钟实验室</title>
        <link>http://example.org/posts/</link>
        <description>所有文章 | 3分钟实验室</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Tue, 25 Apr 2023 00:00:00 &#43;0000</lastBuildDate><atom:link href="http://example.org/posts/" rel="self" type="application/rss+xml" /><item>
    <title>JavaScript Promise async await</title>
    <link>http://example.org/promise/</link>
    <pubDate>Tue, 25 Apr 2023 00:00:00 &#43;0000</pubDate>
    <author>左风</author>
    <guid>http://example.org/promise/</guid>
    <description><![CDATA[状态 promise 的状态分为三种
初始状态(pending) 成功状态(fulfilled) 失败状态(rejected) 一个promise一定处于这三种状态，不可能是其他状态。 构造函数 创建一个promise需要通过构造函数
1 new Promise((resolve, reject) =&gt; {}); 构造函数接收一个函数作为参数，而这个函数的参数resolve，reject 都是函数。 调用resolve 可以使这个promise的状态从 初始状态(pending) 变为 成功状态(fulfilled)。 调用reject 可以使这个promise的状态从 初始状态(pending) 变为 失败状态(rejected) 。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 console.log( new Promise((resolve, reject) =&gt; { resolve() }) ); /*打印结果 [[Prototype]]: promise [[promiseState]]: &#34;fulfilled&#34; 注意看这里的状态 [[promiseResult]]: undefined */ console.log( new Promise((resolve, reject) =&gt; { reject() }) ); /*打印结果 [[Prototype]]: promise [[promiseState]]: &#34;rejected&#34; 注意看这里的状态 [[promiseResult]]: undefined */ ::: tip resolve() 和 reject() 可以接收任何形式的参数，具体作用往下看 :::]]></description>
</item>
<item>
    <title>JavaScript 深浅拷贝</title>
    <link>http://example.org/copy/</link>
    <pubDate>Tue, 25 Apr 2023 00:00:00 &#43;0000</pubDate>
    <author>左风</author>
    <guid>http://example.org/copy/</guid>
    <description><![CDATA[概念 浅拷贝和深拷贝主要针对的是引用数据类型（数组 对象），基础数据类型不存在深浅拷贝问题。
浅拷贝 1 2 3 4 5 6 7 8 9 10 const obj1 = { name: &#34;小明&#34;, age: &#34;18&#34;, }; const obj2 = obj1; obj2.name = &#34;小红&#34;; console.log(obj1.name); // 小红 console.log(obj2.name); // 小红 这里我们发现，更改了obj2.name之后 obj1.name 也变成了小红，这就是浅拷贝。 原因是因为obj1和obj2引用的是同一块内存地址,严格意义上都是相等的。
1 console.log(obj1 === obj2);// true 深拷贝 不难发现，基础数据类型不会出现浅拷贝的情况，而引用数据类型中的属性 例如obj1.name就是基础数据类型。
如果我们这样操作就不会出现浅拷贝的情况。
1 2 3 4 5 6 7 8 9 10 11 12 const obj1 = { name: &#34;小明&#34;, age: &#34;18&#34;, }; const obj2 = {}; obj2.]]></description>
</item>
<item>
    <title>JavaScript 事件循环 异步</title>
    <link>http://example.org/eventloop/</link>
    <pubDate>Tue, 25 Apr 2023 00:00:00 &#43;0000</pubDate>
    <author>左风</author>
    <guid>http://example.org/eventloop/</guid>
    <description><![CDATA[首先介绍几个概念，这里先做了解，后面用到再看。
同步任务
整个script脚本，除异步任务外，都是同步任务。。。
异步任务
包括setTimeout, setInterval, promise.then, 各种事件绑定等。
其中异步任务又分为
宏任务 setTimeout, setInterval, ajax请求，各种事件绑定等。 微任务promise.then 下面介绍我们运行js代码拥有哪些东西。
js执行栈(js主线程) 运行环境(这里主要指的是浏览器) 宏任务队列 微任务队列
如下图所示 由于js是单线程的，所以任务只能一个个执行，下面我们整理一下代码的执行流程。
1.js代码从上往下执行，同步任务直接执行。 2.如遇到异步任务则需要判断是宏任务还是微任务，把宏任务加入到宏任务队列，微任务加入到微任务队列。 3.执行栈中任务执行完毕，js线程空闲，检查微任务队列是否有微任务，如果有则把微任务加入执行栈并执行，直到微任务队列为空。 4.当执行栈，微任务队列都为空时，检查宏任务队列是否有宏任务，如果有取第一个加入执行栈并执行，回到第一步。 简单来说就是 同步任务 &ndash;&gt; 所有微任务 &ndash;&gt; 单个宏任务 &ndash;&gt; 所有微任务 &ndash;&gt; 单个宏任务 如此循环。
下面代码演示。 1 2 3 4 5 6 7 8 9 10 11 12 13 console.log(1); // 同步任务立马执行 setTimeout(() =&gt; { console.log(2); // 异步宏任务 放入宏任务队列 }, 0); new Promise((resolve, reject) =&gt; { resolve(); }).then(() =&gt; { console.]]></description>
</item>
<item>
    <title>JavaScript 原型 原型链</title>
    <link>http://example.org/prototype/</link>
    <pubDate>Tue, 25 Apr 2023 00:00:00 &#43;0000</pubDate>
    <author>左风</author>
    <guid>http://example.org/prototype/</guid>
    <description><![CDATA[构造函数 了解原型之前我们需要明白另外一件事情，什么是构造函数。
function student(){} 这是一个函数,我们可以直接调用它student()因为它的函数体是空的,所以不会执行任何操作。
但我们还有另外一种办法调用它 那就是new let a = new student()这句代码意思是 创建一个 student 类型的对象 a 把student()函数当构造函数使用。
其实所有的函数只要使用new来调用都是构造函数，反过来说构造函数和函数的区别就是是否用new来调用。
1 2 3 4 function student() {} let a = new student(); console.log(a); //student {} console.log(a instanceof student); //true 下面我们给出一个稍微标准点的构造函数。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function student(name, age) { this.name = name; this.age = age; this.sayName = function () { console.]]></description>
</item>
<item>
    <title>Laf 开发指南</title>
    <link>http://example.org/lafguide/</link>
    <pubDate>Tue, 25 Apr 2023 00:00:00 &#43;0000</pubDate>
    <author>左风</author>
    <guid>http://example.org/lafguide/</guid>
    <description><![CDATA[Laf 开发指南（比官方文档更详细）待更新 laf 金丝雀版本已经不删档上线了，作为一个使用 laf 多年的开发者，毕业设计我都是用 laf 写的&hellip; 我深知 laf 对于前端程序员意味着什么，通过简单的学习就可以进行全栈开发 部署，带来了极致的开发体验，脏活累活 laf 都帮我们解决了，用 laf 甚至可以延年益寿&hellip;
本文我根据 laf 功能模块来一一介绍，可以顺序阅读，也可以根据右边导航栏找到需要了解的模块。
如果你还不知道 laf 是什么 参考：三分钟学会 Laf
:::tip 因本文图片较多，打开设备的夜间模式，或者点击本站右上角的夜间模式开关，获得最佳阅读体验。
部分图片看不清细节，PC 端 CTRL + 鼠标滚轮 放大，移动端双指放大。 :::
云函数基本功能 云函数是 laf 最重要的功能了，所以我们就从新建一个云函数开始。 进入到 laf 开发页面我们可以点击中间的立即创建和左上角的 + 符号来创建一个云函数。 参考下图的介绍来创建你的第一个云函数吧
创建完之后我们熟悉一下关于云函数都有哪些功能。
搜索 编辑 删除 编写 发布 查看 传参 调试 依赖 控制台 运行结果 集合基本功能 集合我们可以理解为数据库，每一个集合对应的就是一张表。
和创建云函数一样，我们来创建一个集合。 添加一条数据 编辑 查询 删除 存储基本功能 存储这里就是存放我们文件的地方，首先我们创建一个 bucket 上传 网站托管 日志基本功能 日志就是我们云函数的执行日志，我们回到最初创建的 get-data 函数，写入以下代码，并点击右侧的运行按钮。]]></description>
</item>
<item>
    <title>三分钟部署 laf (win 版本)</title>
    <link>http://example.org/deploylaf/</link>
    <pubDate>Tue, 25 Apr 2023 00:00:00 &#43;0000</pubDate>
    <author>左风</author>
    <guid>http://example.org/deploylaf/</guid>
    <description><![CDATA[起步 演示系统： win11专业版（这里一定是专业版，家庭版的同学去某宝花几块钱升级一下）
首先我们需要用到一个工具 Multipass。
Multipass 是快速创建一个 linux 虚拟机的工具。 我们创建 linux 虚拟机干啥呢？用来部署 k8s 。 什么是 k8s ？ 简单理解就是可以把多台服务器，组成一个超级机器，一起来管理的一个平台。 部署k8s干啥？ 因为 laf 当前只支持在 k8s 上部署。 我们反过来说： laf 当前只支持在 k8s 上部署， k8s 只支持 linux ,而我们只有一个 windows 系统。
安装 Multipass 点击这里安装 Multipass win 版本。
一路选择下一步安装，这个地方需要注意的是一定要选这个，如果这个选项是黑的证明你的系统不是专业版。 安装完毕之后，重启电脑。
重启完执行命令。
1 2 // 启动 laf-dev 虚拟器 分配 cpus 2 memory 4G disk 50G multipass launch --name laf-dev --cpus 2 --memory 4G --disk 50G :::tip 如果遇到 launch failed: Remote &quot;&quot; is unknown or unreachable.]]></description>
</item>
<item>
    <title>三分钟上手 Next.js</title>
    <link>http://example.org/next/</link>
    <pubDate>Tue, 25 Apr 2023 00:00:00 &#43;0000</pubDate>
    <author>左风</author>
    <guid>http://example.org/next/</guid>
    <description><![CDATA[起步 Next.js 能干啥？
Compiling ： 把我们写的 jsx TS 等编译成浏览器认识的 js。 Minifying ： 把代码里的 缩进 空格 换行 删掉，减少文件大小来提高性能。 Bundling ： 把多个文件打包组合成更少的文件。 Code Splitting ：把代码按需分成小块，通过只加载需要的部分来减少加载时间。 Rendering ：支持服务端渲染直接发送 html 文件到浏览器，提升渲染速度。 。。。来点更直接的，Next.js 是 react 的一个框架，提供了很多方便的功能。
以下命令创建一个 next 项目。
1 npx create-next-app@latest 用 vscode 打开并清空 src/pages/index.js 和 src/styles/globals.css
然后在 index.js 中贴入以下代码。
1 2 3 4 5 6 7 export default function Home() { return ( &lt;&gt; &lt;h1&gt;你好,next&lt;/h1&gt; &lt;/&gt; ) } npm run dev 启动项目，打开 localhost:3000 快速刷新 更改 next 为 小明 就会发现浏览器视图已经更新，无需手动刷新，这就是快速刷新。]]></description>
</item>
<item>
    <title>三分钟写了一个专属 ChatGPT ，Laf 创始人：明天来上班！</title>
    <link>http://example.org/offer/</link>
    <pubDate>Tue, 25 Apr 2023 00:00:00 &#43;0000</pubDate>
    <author>左风</author>
    <guid>http://example.org/offer/</guid>
    <description><![CDATA[起因 故事是这样的，一个月黑风高的夜晚，我掏出手机像往常一样打开朋友圈。 一开始我是不相信的，直到我（快速的） &ndash;&gt; 打开 laf &ndash;&gt; 创建应用 &ndash;&gt; 新建云函数 &ndash;&gt; 写上三行代码 &ndash;&gt; 点击运行，呦呵！还真通了。
然后我又（快速的）&ndash;&gt; 新建前端项目 &ndash;&gt; 写点样式 &ndash;&gt; 接入laf &ndash;&gt; 写点逻辑 &ndash;&gt; 打包项目 &ndash;&gt; 上传到 laf 托管，获得一个线上的地址：https://jyf6wk-chat-gpt.site.laf.dev/
随便问两句试试看。
不得了不得了，赶紧发给我的朋友们装个杯。
再顺手发到大型 同性交友群 技术交流群。
契机 没多大会，一个 基友 米开朗基杨加我好友。
我一想博客也很久没更新了（主要是他叫了我一声大佬），就顺便写一篇吧，然后我（迅速又帅气的）取出我的 68键，拾光白轴，PBT豆奶键帽的键盘，行云流水的码完了一篇文章：三分钟拥有自己的 ChatGPT (从开发到上线)
这篇文章经过 米开朗基杨 的润色之后几番转载， laf 一天增加了上百个 star，四百多应用，直接送上 Github Trending。 转折 然后，然后重点来了。
THE END life is short, you need laf 😃 https://laf.dev/]]></description>
</item>
<item>
    <title>三分钟学会 Chakra-UI 写一个厉害的登录页</title>
    <link>http://example.org/chakra/</link>
    <pubDate>Tue, 25 Apr 2023 00:00:00 &#43;0000</pubDate>
    <author>左风</author>
    <guid>http://example.org/chakra/</guid>
    <description><![CDATA[三分钟学会 Chakra-UI 写一个厉害的登录页 起步 老规矩创建一个项目用 vscode 打开
1 2 3 npm create vite chakra-demo --template react cd chakra-demo code . 打开后删除 src 下的其他文件夹，只保留 App.jsx 和 main.jsx 写入以下代码
App.jsx
1 2 3 4 5 function App() { return &lt;h1&gt;你好,chakra&lt;/h1&gt; } export default App main.jsx
1 2 3 4 5 6 7 8 9 import React from &#39;react&#39; import ReactDOM from &#39;react-dom/client&#39; import App from &#39;./App&#39; ReactDOM.createRoot(document.getElementById(&#39;root&#39;)).render( &lt;React.StrictMode&gt; &lt;App /&gt; &lt;/React.StrictMode&gt;, ) 准备好这些以后 安装 chakra 并且安装一下依赖 把程序 run 起来]]></description>
</item>
<item>
    <title>三分钟学会 ClickToComponent</title>
    <link>http://example.org/clicktocomponent/</link>
    <pubDate>Tue, 25 Apr 2023 00:00:00 &#43;0000</pubDate>
    <author>左风</author>
    <guid>http://example.org/clicktocomponent/</guid>
    <description><![CDATA[起步 老规矩创建一个项目用 vscode 打开
1 2 3 4 5 6 npm create vite clickToComponent-demo --template react cd clickToComponent-demo // 这里顺手把依赖装了 npm i npm install click-to-react-component code . 删除 src 下面的多余文件，保留 App.jsx main.jsx 并创建 black.jsx red.jsx 分别写入以下代码 main.jsx
1 2 3 4 5 6 7 8 9 10 11 12 13 import React from &#39;react&#39; import ReactDOM from &#39;react-dom/client&#39; import App from &#39;./App&#39; // 这里引入 import { ClickToComponent } from &#34;click-to-react-component&#34;; ReactDOM.]]></description>
</item>
</channel>
</rss>
