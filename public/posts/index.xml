<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>所有文章 - 3分钟实验室</title>
        <link>http://example.org/posts/</link>
        <description>所有文章 | 3分钟实验室</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Thu, 15 Jun 2023 00:00:00 &#43;0000</lastBuildDate><atom:link href="http://example.org/posts/" rel="self" type="application/rss+xml" /><item>
    <title>30 秒拥有自己的 ChatGPT（一行代码不用写）</title>
    <link>http://example.org/sealos/</link>
    <pubDate>Thu, 15 Jun 2023 00:00:00 &#43;0000</pubDate>
    <author>左风</author>
    <guid>http://example.org/sealos/</guid>
    <description><![CDATA[先上效果图
话不多说直接开整！
预备条件 有一台能打开浏览器的电脑 有一个 ChatGPT 的 Key 如果你没有我送你一个 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
开始 浏览器打开这个网址 https://sealos.io/ 点击 在线使用 然后登陆进来。
点这个 AppLaunchpad 点右上新建 这个页面里需要输入的东西有：
文末会解释为什么填写这些，现在我们先快速搭建起来
AppName 这个随便起个名字就可以 Image Name 填写 yidadaa/chatgpt-next-web CPU 选择 1 Memory 选择 521Mi Container Ports 填写 3000 Accessible to the Public 这个点击打开 填写完这些后点击右上角 Deploy Application 到这个页面点击这个链接访问大功告成
如果访问不了就稍微等一会，可能是还没部署成功
打开之后在这里填入 ChatGPT 的 Key
ok 搞定！
干了什么？ Image Name 填写 yidadaa/chatgpt-next-web ，这一步是写了一个开源项目作者提供的镜像名，这里不多做解释，如果你遇到一个项目开源并且提供的容器的部署方式（就是能找到镜像名）都可以用这种方式一建部署。
CPU 选择 1 Memory 选择 521Mi ，这里是我测试的最低能跑这个项目的配置，如果给的低了项目跑不起来。
Container Ports 填写 3000 ，这里是项目作者暴露的端口，一般都会写在部署文档上，写什么填什么就好了。]]></description>
</item>
<item>
    <title>什么是云开发？</title>
    <link>http://example.org/clouddevelopment/</link>
    <pubDate>Thu, 11 May 2023 00:00:00 &#43;0000</pubDate>
    <author>左风</author>
    <guid>http://example.org/clouddevelopment/</guid>
    <description><![CDATA[本文主要解决三个问题 ：
云开发是什么 我们为什么需要云开发 如何快速上手地表最强云开发 Laf（https://laf.run） 云开发是什么？ 我们来看看 GPT 怎么说。
一句话总结：云开发是一种模式，区别于传统开发，传统开发有的东西，云开发都有，传统开发能实现的，云开发也都能实现。
那么第二个问题就来了，既然都有都能实现，我们为什么需要云开发？
我们为什么需要云开发？ 为了搞懂这个问题，我们需要先知道传统的开发流程以及所需要的技术栈，我们这里以云开发中的战斗机 Laf（laf.run）举例。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 传统开发流程： 1.购买服务器 2.配置服务器的环境数据库等 3.编写接口代码 4.把代码部署到服务器 5.前端搞定剩余工作 6.前端项目打包部署到服务器 7.后续运维工作 云开发流程： 1.打开浏览器编写接口代码 2.前端搞定剩余工作 3.项目一键托管上线到云平台 传统开发所需技术栈： 1.一门后端语言 2.后端框架 3.数据库 4.缓存技术 5.操作系统相关 6.前端三件套+框架+常用库 云开发所需技术栈： 1.云开发的数据库和文件操作 2.前端三件套+框架+常用库 了解这些之后，我想根本不需要明白这些实现细节，单单从字数上就可以感受到，云开发模式和传统开发模式之间的区别。
简单总结一下就是三省：省心省力又省钱。
用 Laf，前端我们用 js/ts 来写代码，后端接口我们还是用 js/ts 来写代码，这意味着什么？这意味着只需要掌握一门开发语言，就可以前后端通杀了，这意味着前端工程师可以瞬间变成全栈开发，意味着前端和后端再也不用吵架了。
用 Laf，可以节约服务器运维，多环境部署，告别配置调试 nginx ，告别为每个项目手动部署数据库和安全顾虑，告别 coding 一分钟发布半小时的尴尬场景等等。]]></description>
</item>
<item>
    <title>JavaScript Promise async await</title>
    <link>http://example.org/promise/</link>
    <pubDate>Tue, 25 Apr 2023 00:00:00 &#43;0000</pubDate>
    <author>左风</author>
    <guid>http://example.org/promise/</guid>
    <description><![CDATA[状态 promise 的状态分为三种
初始状态(pending) 成功状态(fulfilled) 失败状态(rejected) 一个promise一定处于这三种状态，不可能是其他状态。 构造函数 创建一个promise需要通过构造函数
1 new Promise((resolve, reject) =&gt; {}); 构造函数接收一个函数作为参数，而这个函数的参数resolve，reject 都是函数。 调用resolve 可以使这个promise的状态从 初始状态(pending) 变为 成功状态(fulfilled)。 调用reject 可以使这个promise的状态从 初始状态(pending) 变为 失败状态(rejected) 。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 console.log( new Promise((resolve, reject) =&gt; { resolve() }) ); /*打印结果 [[Prototype]]: promise [[promiseState]]: &#34;fulfilled&#34; 注意看这里的状态 [[promiseResult]]: undefined */ console.log( new Promise((resolve, reject) =&gt; { reject() }) ); /*打印结果 [[Prototype]]: promise [[promiseState]]: &#34;rejected&#34; 注意看这里的状态 [[promiseResult]]: undefined */ ::: tip resolve() 和 reject() 可以接收任何形式的参数，具体作用往下看 :::]]></description>
</item>
<item>
    <title>JavaScript 深浅拷贝</title>
    <link>http://example.org/copy/</link>
    <pubDate>Tue, 25 Apr 2023 00:00:00 &#43;0000</pubDate>
    <author>左风</author>
    <guid>http://example.org/copy/</guid>
    <description><![CDATA[概念 浅拷贝和深拷贝主要针对的是引用数据类型（数组 对象），基础数据类型不存在深浅拷贝问题。
浅拷贝 1 2 3 4 5 6 7 8 9 10 const obj1 = { name: &#34;小明&#34;, age: &#34;18&#34;, }; const obj2 = obj1; obj2.name = &#34;小红&#34;; console.log(obj1.name); // 小红 console.log(obj2.name); // 小红 这里我们发现，更改了obj2.name之后 obj1.name 也变成了小红，这就是浅拷贝。 原因是因为obj1和obj2引用的是同一块内存地址,严格意义上都是相等的。
1 console.log(obj1 === obj2);// true 深拷贝 不难发现，基础数据类型不会出现浅拷贝的情况，而引用数据类型中的属性 例如obj1.name就是基础数据类型。
如果我们这样操作就不会出现浅拷贝的情况。
1 2 3 4 5 6 7 8 9 10 11 12 const obj1 = { name: &#34;小明&#34;, age: &#34;18&#34;, }; const obj2 = {}; obj2.]]></description>
</item>
<item>
    <title>JavaScript 事件循环 异步</title>
    <link>http://example.org/eventloop/</link>
    <pubDate>Tue, 25 Apr 2023 00:00:00 &#43;0000</pubDate>
    <author>左风</author>
    <guid>http://example.org/eventloop/</guid>
    <description><![CDATA[首先介绍几个概念，这里先做了解，后面用到再看。
同步任务
整个script脚本，除异步任务外，都是同步任务。。。
异步任务
包括setTimeout, setInterval, promise.then, 各种事件绑定等。
其中异步任务又分为
宏任务 setTimeout, setInterval, ajax请求，各种事件绑定等。 微任务promise.then 下面介绍我们运行js代码拥有哪些东西。
js执行栈(js主线程) 运行环境(这里主要指的是浏览器) 宏任务队列 微任务队列
如下图所示 由于js是单线程的，所以任务只能一个个执行，下面我们整理一下代码的执行流程。
1.js代码从上往下执行，同步任务直接执行。 2.如遇到异步任务则需要判断是宏任务还是微任务，把宏任务加入到宏任务队列，微任务加入到微任务队列。 3.执行栈中任务执行完毕，js线程空闲，检查微任务队列是否有微任务，如果有则把微任务加入执行栈并执行，直到微任务队列为空。 4.当执行栈，微任务队列都为空时，检查宏任务队列是否有宏任务，如果有取第一个加入执行栈并执行，回到第一步。 简单来说就是 同步任务 &ndash;&gt; 所有微任务 &ndash;&gt; 单个宏任务 &ndash;&gt; 所有微任务 &ndash;&gt; 单个宏任务 如此循环。
下面代码演示。 1 2 3 4 5 6 7 8 9 10 11 12 13 console.log(1); // 同步任务立马执行 setTimeout(() =&gt; { console.log(2); // 异步宏任务 放入宏任务队列 }, 0); new Promise((resolve, reject) =&gt; { resolve(); }).then(() =&gt; { console.]]></description>
</item>
<item>
    <title>JavaScript 原型 原型链</title>
    <link>http://example.org/prototype/</link>
    <pubDate>Tue, 25 Apr 2023 00:00:00 &#43;0000</pubDate>
    <author>左风</author>
    <guid>http://example.org/prototype/</guid>
    <description><![CDATA[构造函数 了解原型之前我们需要明白另外一件事情，什么是构造函数。
function student(){} 这是一个函数,我们可以直接调用它student()因为它的函数体是空的,所以不会执行任何操作。
但我们还有另外一种办法调用它 那就是new let a = new student()这句代码意思是 创建一个 student 类型的对象 a 把student()函数当构造函数使用。
其实所有的函数只要使用new来调用都是构造函数，反过来说构造函数和函数的区别就是是否用new来调用。
1 2 3 4 function student() {} let a = new student(); console.log(a); //student {} console.log(a instanceof student); //true 下面我们给出一个稍微标准点的构造函数。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function student(name, age) { this.name = name; this.age = age; this.sayName = function () { console.]]></description>
</item>
<item>
    <title>Laf 开发指南</title>
    <link>http://example.org/lafguide/</link>
    <pubDate>Tue, 25 Apr 2023 00:00:00 &#43;0000</pubDate>
    <author>左风</author>
    <guid>http://example.org/lafguide/</guid>
    <description><![CDATA[Laf 开发指南（比官方文档更详细）待更新 laf 金丝雀版本已经不删档上线了，作为一个使用 laf 多年的开发者，毕业设计我都是用 laf 写的&hellip; 我深知 laf 对于前端程序员意味着什么，通过简单的学习就可以进行全栈开发 部署，带来了极致的开发体验，脏活累活 laf 都帮我们解决了，用 laf 甚至可以延年益寿&hellip;
本文我根据 laf 功能模块来一一介绍，可以顺序阅读，也可以根据右边导航栏找到需要了解的模块。
如果你还不知道 laf 是什么 参考：三分钟学会 Laf
:::tip 因本文图片较多，打开设备的夜间模式，或者点击本站右上角的夜间模式开关，获得最佳阅读体验。
部分图片看不清细节，PC 端 CTRL + 鼠标滚轮 放大，移动端双指放大。 :::
云函数基本功能 云函数是 laf 最重要的功能了，所以我们就从新建一个云函数开始。 进入到 laf 开发页面我们可以点击中间的立即创建和左上角的 + 符号来创建一个云函数。 参考下图的介绍来创建你的第一个云函数吧
创建完之后我们熟悉一下关于云函数都有哪些功能。
搜索 编辑 删除 编写 发布 查看 传参 调试 依赖 控制台 运行结果 集合基本功能 集合我们可以理解为数据库，每一个集合对应的就是一张表。
和创建云函数一样，我们来创建一个集合。 添加一条数据 编辑 查询 删除 存储基本功能 存储这里就是存放我们文件的地方，首先我们创建一个 bucket 上传 网站托管 日志基本功能 日志就是我们云函数的执行日志，我们回到最初创建的 get-data 函数，写入以下代码，并点击右侧的运行按钮。]]></description>
</item>
<item>
    <title>三分钟部署 laf (win 版本)</title>
    <link>http://example.org/deploylaf/</link>
    <pubDate>Tue, 25 Apr 2023 00:00:00 &#43;0000</pubDate>
    <author>左风</author>
    <guid>http://example.org/deploylaf/</guid>
    <description><![CDATA[起步 演示系统： win11专业版（这里一定是专业版，家庭版的同学去某宝花几块钱升级一下）
首先我们需要用到一个工具 Multipass。
Multipass 是快速创建一个 linux 虚拟机的工具。 我们创建 linux 虚拟机干啥呢？用来部署 k8s 。 什么是 k8s ？ 简单理解就是可以把多台服务器，组成一个超级机器，一起来管理的一个平台。 部署k8s干啥？ 因为 laf 当前只支持在 k8s 上部署。 我们反过来说： laf 当前只支持在 k8s 上部署， k8s 只支持 linux ,而我们只有一个 windows 系统。
安装 Multipass 点击这里安装 Multipass win 版本。
一路选择下一步安装，这个地方需要注意的是一定要选这个，如果这个选项是黑的证明你的系统不是专业版。 安装完毕之后，重启电脑。
重启完执行命令。
1 2 // 启动 laf-dev 虚拟器 分配 cpus 2 memory 4G disk 50G multipass launch --name laf-dev --cpus 2 --memory 4G --disk 50G :::tip 如果遇到 launch failed: Remote &quot;&quot; is unknown or unreachable.]]></description>
</item>
<item>
    <title>三分钟上手 Next.js</title>
    <link>http://example.org/next/</link>
    <pubDate>Tue, 25 Apr 2023 00:00:00 &#43;0000</pubDate>
    <author>左风</author>
    <guid>http://example.org/next/</guid>
    <description><![CDATA[起步 Next.js 能干啥？
Compiling ： 把我们写的 jsx TS 等编译成浏览器认识的 js。 Minifying ： 把代码里的 缩进 空格 换行 删掉，减少文件大小来提高性能。 Bundling ： 把多个文件打包组合成更少的文件。 Code Splitting ：把代码按需分成小块，通过只加载需要的部分来减少加载时间。 Rendering ：支持服务端渲染直接发送 html 文件到浏览器，提升渲染速度。 。。。来点更直接的，Next.js 是 react 的一个框架，提供了很多方便的功能。
以下命令创建一个 next 项目。
1 npx create-next-app@latest 用 vscode 打开并清空 src/pages/index.js 和 src/styles/globals.css
然后在 index.js 中贴入以下代码。
1 2 3 4 5 6 7 export default function Home() { return ( &lt;&gt; &lt;h1&gt;你好,next&lt;/h1&gt; &lt;/&gt; ) } npm run dev 启动项目，打开 localhost:3000 快速刷新 更改 next 为 小明 就会发现浏览器视图已经更新，无需手动刷新，这就是快速刷新。]]></description>
</item>
<item>
    <title>三分钟写了一个专属 ChatGPT ，Laf 创始人：明天来上班！</title>
    <link>http://example.org/offer/</link>
    <pubDate>Tue, 25 Apr 2023 00:00:00 &#43;0000</pubDate>
    <author>左风</author>
    <guid>http://example.org/offer/</guid>
    <description><![CDATA[起因 故事是这样的，一个月黑风高的夜晚，我掏出手机像往常一样打开朋友圈。 一开始我是不相信的，直到我（快速的） &ndash;&gt; 打开 laf &ndash;&gt; 创建应用 &ndash;&gt; 新建云函数 &ndash;&gt; 写上三行代码 &ndash;&gt; 点击运行，呦呵！还真通了。
然后我又（快速的）&ndash;&gt; 新建前端项目 &ndash;&gt; 写点样式 &ndash;&gt; 接入laf &ndash;&gt; 写点逻辑 &ndash;&gt; 打包项目 &ndash;&gt; 上传到 laf 托管，获得一个线上的地址：https://jyf6wk-chat-gpt.site.laf.dev/
随便问两句试试看。
不得了不得了，赶紧发给我的朋友们装个杯。
再顺手发到大型 同性交友群 技术交流群。
契机 没多大会，一个 基友 米开朗基杨加我好友。
我一想博客也很久没更新了（主要是他叫了我一声大佬），就顺便写一篇吧，然后我（迅速又帅气的）取出我的 68键，拾光白轴，PBT豆奶键帽的键盘，行云流水的码完了一篇文章：三分钟拥有自己的 ChatGPT (从开发到上线)
这篇文章经过 米开朗基杨 的润色之后几番转载， laf 一天增加了上百个 star，四百多应用，直接送上 Github Trending。 转折 然后，然后重点来了。
THE END life is short, you need laf 😃 https://laf.dev/]]></description>
</item>
</channel>
</rss>
